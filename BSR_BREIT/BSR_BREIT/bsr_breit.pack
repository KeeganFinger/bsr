!=====================================================================
!     PROGRAM   B S R _ B R E I T                        b10 -> v.10
!
!               C O P Y R I G H T -- 2004
!
!     Written by:   Oleg Zatsarinny
!                   email: oleg_zoi@yahoo.com
!======================================================================
!
!    generates angular coefficient in non-orthogonal mode
!
!----------------------------------------------------------------------
!
!    INPUT ARGUMENTS:
!
!    klsp1,klsp2  - range of partial wave in BSR calculations,
!                   then cfg.001, cfg.002, ..., are input files
!                   (default -> 0, with input file is cfg.inp)
!
!    oper  - character(7), where each position can be 0 or 1,
!            and indicate the operator under consideration:
!            oper(1) - OVERLAPS
!            oper(2) - KINATIC ENERGY
!            oper(3) - TWO-ELECTRON ELECTROSTATIC
!            oper(4) - SPIN ORBIT
!            oper(5) - SPIN-OTHER-ORBIT
!            oper(6) - SPIN-SPIN
!            oper(7) - ORBIT-ORBIT
!            Default -> 1110000 - non-relativistic calculations
!
!    mk    - max.multipole index (default -> 9, see module param_br)
!
!    nzero - zero-order dimension (default -> 0, all configurations)
!                                 (not used at the moment !)
!
!----------------------------------------------------------------------
!
!    example:    1.  bsr_breit
!                2.  bsr_breit klsp1=1 klsp2=5 oper=1111110
!                3.  bsr_breit km=5
!
!    last version of bsr_breit -> b10
!
!----------------------------------------------------------------------
!
!    INPUT FILES:
!
!    cfg.###     -  configuration list for partial wave ### = klsp
!                   (cfg.inp in case klsp = 0)
!
!    int_bnk.### -  input data bank for angular coefficients
!                   (optional; int_bnk in case klsp = 0)
!
!
!    OUTPUT FILES:
!
!    int_bnk.###  - output data bank for angular coefficients
!                   (int_bnk in case klsp = 0)
!
!---------------------------------------------------------------------
!    packing list:
!
!    mod_param.f90
!    mod_boef.f90
!    mod_coef.f90
!    mod_det.f90
!    mod_inout.f90
!    mod_inter.f90
!    mod_spinorb.f90
!    mod_termexp.f90
!    mod_zoef.f90
!    add_res.f90
!    conf_loop.f90
!    det_btreit.f90
!    idet_fact.f90
!    incode_int.f90
!    main.f90
!    prepare.f90
!    r_conf.f90
!    term_loop.f90
!    zno_0ee.f90
!    zno_1ee.f90
!    zno_2ee.f90
!    zno_breit.f90
!
!---------------------------------------------------------------------


!======================================================================
      MODULE  param_br
!======================================================================
!
!     main parameters used in the program
!
!     REMARKS:
!
! 1.  Parking basis for orbitals 'jb' should be > nsh,
!     where nsh - max. number of shells, as define in module CONFIGS.
!     We use spectroscopic description for configurations in so-called
!     c-files (MCHF complex) with nsh=8, so it restricts the possible
!     configurations by 8 open shells above some closed-shells core.
!     It seems not to imply strong restrictions in real calculations
!     except inner-shell excitation in many-electron atoms.
!
! 2.  The parking basis for det.overlaps and det.factors (ibd,ibf)
!     seems not to restrict any possible calculations.
!
! 3.  The initial dimensions for some array are found to be enough for
!     simple calculations, do not take much memory and the corresponding
!     arrays will be reallocated dynamically if it is necessary.
!
! 4.  There is hidden parameter 'ibc=1^15~32000' from module CONFIGS
!     which determines here the max.number of differerent symmetries.
!     (in int_bnk we use parking it*ibc+jt). The number of symmetries
!     usually is much less then the number of configurations, so it
!     it does not seem as a restriction.
!
! 5.  Due to mode of parking the integrals, the max. multipole index
!     should be less then jb^4-1 = 9999, that is not a restriction.
!     The default value of mk can be change from the input.
!
! 6.  Parameters jbl,jbm is used for encoding (parking) of two-electron
!     integrals in uncouple lms-reprizantation. It restricts orbitals
!     by l < 64. To reduce this restriction, we can use another parking
!     with 4 indentifiers, instead 3 as now.
!
!----------------------------------------------------------------------
      Implicit none
      Save
! ... tolerence for coefficients:
      Real(8) :: Eps_c = 1.d-7
! ... parking basis for orbitals in the data bank:
      Integer(4), parameter :: jb=10, jb4=jb**4, jb8=jb**8
! ... maximum multipole index:
      Integer(4) :: mk = 7
! ... other parameters:
      Integer(4), parameter :: isd = 20000  ! initial dimension for det.overlaps
      Integer(4), parameter :: jsd = 3      ! avarage size of overlap det.
      Integer(4), parameter :: ibd = 2**15  ! parking basis for det.overlaps
      Integer(4), parameter :: isf = 200000 ! initial dimension for det.factors
      Integer(4), parameter :: jsf = 5      ! avarage number of dets. in def.
      Integer(4), parameter :: ibf = 16     ! parking basis for det.factors
! ... initial (supposed) number of coef.s:
      Integer(4), parameter :: iszoef = 2000    ! in module ZOEF
      Integer(4), parameter :: iscoef = 2500    ! in module COEF
      Integer(4), parameter :: isboef = 50000   ! in module BOEF
      Integer(4), parameter :: isblk  = 5000    ! in module BOEF
      Integer(4), Parameter :: jbl  = 2**7      ! in Check_BOEF
      Integer(4), Parameter :: jbm  = 2**6      ! in Check_BOEF
! ... switch for Vk -> V'k in soo interaction:
      Integer(4) :: is_soo = 0
      End MODULE  param_br


!======================================================================
      MODULE inout_br
!======================================================================
!
!     Containes the names and units for input/output files
!
!     AF  -  standard (default) names
!     BF  -  names with indication of partial wave number
!
!----------------------------------------------------------------------
      Implicit none
      Save
! ... runing information:
      Integer(4) :: pri=66;  Character(40) :: AF_pri = 'bsr_breit.log'
! ... c-file:
      Integer(4) :: nuc=1;  Character(40) :: AF_c = 'cfg.inp'
                            Character(40) :: BF_c = 'cfg.###'
! ... data bank:
      Integer(4) :: nub=2;  Character(40) :: AF_b = 'int_bnk'
                            Character(40) :: BF_b = 'int_bnk.###'
      Logical(1) :: new     ! pointer on the previous calculation
! ... new results if any:
      Integer(4) :: nur=3;  Character(40) :: AF_r = 'int_res'
                            Character(40) :: BF_r = 'int_res.###'
      Logical(1) :: icalc   ! pointer for need of new calculations
! ... scratch files:
      Integer(4) :: nui= 4  ! intermediate results
      Integer(4) :: nus=11  ! for reallocations
      Integer(4) :: nud=12  ! for det. expansions
      Integer(4) :: nua=13  ! for accumulation of data
! ... maximum record length:
      Integer(4), parameter :: mrecl = 100000
!     we introduce this parameter because different platforms have
!     different default record lengths, and it may cause troubles when
!     change computers or compilers
! ... range of partial waves:
      Integer(4) :: klsp1=0, klsp2=0
      End MODULE inout_br
!======================================================================
      Subroutine Open_br(nu,klsp)
!======================================================================
!
!     open (closed) files in the breit_bsr program
!
!----------------------------------------------------------------------
      USE inout_br
      Implicit none
      Integer(4), Intent(in) :: nu,klsp
      Integer(4) :: i,iarg
      Character(40) :: AF,BF
      Character(3) :: ALSP
      Logical :: EX
      Integer(4), External :: IARGC
      Call Anumber(klsp,3,ALSP)
       Select case(nu)
       Case(1)               ! c-file
        AF = AF_c
        if(klsp.gt.0) then
         i=Index(BF_c,'.'); AF=BF_c(1:i)//ALSP; BF_c=AF
        else
         iarg = IARGC()
         if(iarg.gt.0) then
          Call GETARG(1,BF); i=INDEX(BF,'=')
          if(i.eq.0) then
           i=INDEX(BF,'.')-1; if(i.lt.0) i=LEN_TRIM(BF)
           AF=BF(1:i)//'.c'; AF_b = BF(1:i)//'.bnk'
          end if
         end if
        end if
        Call Check_file(AF)
        Open(nu,file=AF,status='OLD')
       Case(2)               ! bnk-file
        AF = AF_b
        if(klsp.gt.0) then
         i=Index(BF_b,'.'); AF=BF_b(1:i)//ALSP; BF_b=AF
        end if
        Inquire (FILE=AF, exist=EX)
        new=.TRUE.
        if(EX) then
         new = .FALSE.
         Open(nub,file=AF,form='UNFORMATTED',STATUS='OLD')
        end if
        Case(3)
         AF = AF_r
         if(klsp.gt.0) then
          i=Index(BF_r,'.'); AF=BF_r(1:i)//ALSP; BF_r=AF
         end if
         Open(nur,file=AF,form='UNFORMATTED')
        Case(66)
         AF = AF_pri;  Open(nu,file=AF)
        Case(4,11,12,13)
         Open(nu,form='UNFORMATTED',status='SCRATCH')
        Case default
         Stop ' open_br: nu is out of list '
       End select
       End Subroutine Open_br


!======================================================================
      MODULE spin_orbitals
!======================================================================
!
!     contains rather fancy but effective description of two determinant
!     wave function under consideration
!
!----------------------------------------------------------------------
      USE configs, only: nsh ! defines the max. number of shells
      IMPLICIT NONE
      SAVE
! ... possible ml and ms values in chosen order:
      Integer(4) :: mls_max
      Integer(4), Dimension(:), Allocatable :: ml_orb, ms_orb
! ... common list of different orbital symmetries for two determinants:
!
!     NSYM  - number of symmetries:  l,ml,ms ->  Lsym,Msym,Ssym
!     IPSYM - pointer on the last given symmetry in the list
!     KSYM  - number of orbitals with given symmetry
!     nnsym - principal quantum numbers
!     Isym  - pointer on the original position in configuration
      Integer(4) :: NSYM
      Integer(4), Allocatable, Dimension(:) :: Lsym,Lsym1,Lsym2
      Integer(4), Allocatable, Dimension(:) :: Msym,Msym1,Msym2
      Integer(4), Allocatable, Dimension(:) :: Ssym,Ssym1,Ssym2
      Integer(4), Allocatable, Dimension(:) :: IPsym1,IPsym2
      Integer(4), Allocatable, Dimension(:) :: Ksym1 ,Ksym2
      Integer(4), Allocatable, Dimension(:) :: nnsym1,nnsym2
      Integer(4), Allocatable, Dimension(:) :: Isym1,Isym2
! ... shell values:
!     md(i)  - the max.number of det.'s for the i-th subshell
!     nd(i)  - determinant under consideration
!     in(i)  - pointers on the orbitals of given shell
!     MS,ML  - shell MS,ML
!     MSp,MLp - intermediate values MS,ML
      Integer(4), Dimension(nsh) :: md,nd,in
      Integer(4), Dimension(nsh) :: MS,ML, MSp,MLp
      Integer(4) :: kz1,kz2     ! number of perturbations
! ... pointer of orbitals for given shell
      Integer(4), Allocatable, Dimension(:) :: Idet,Jdet
! ... auxiliary arrays
      Integer(4), Allocatable, Dimension(:) :: N1,N2,N3,N4, NP
      End module spin_orbitals


!======================================================================
      MODULE term_exp
!======================================================================
!
!     Containes the term-dependent coefficients of det.expansion
!     of two given conf.symmetries under consideration.
!
!----------------------------------------------------------------------
      Implicit none
      Save
      Integer(4) :: ILT1,ILT2   ! total L
      Integer(4) :: IST1,IST2   ! total S
      Integer(4) :: MLT,MST     ! total ML and MS
      Integer(4) :: kd1,kd2     ! det. under consideration
! ... lists of ang.symmetries (1:kt)
      Integer(4) :: kt1,kt2
      Integer(4), Allocatable, Dimension(:) :: IP_kt1,IP_kt2
! ... pointer on non-zero determinants (1:ne,1:kdt)
      Integer(4) :: kdt1,kdt2
      Integer(4), Allocatable, Dimension(:,:) :: IP_det1,IP_det2
! ... term-dependent det. expension coefficients (1:kt,1:kdt)
      Real(8),  Allocatable, Dimension(:,:) :: C_det1, C_det2
      End MODULE term_exp


!======================================================================
      MODULE boef_list
!======================================================================
!
!     Containes the two-electron integrals for matrix elements
!     in uncouple nlms-representation.
!     This list is introduced to decrease the number of calls for
!     ZNO_breit subroutine. Used in the ZNO_2ee routine.
!     The coefficient in the list are recorded by blocks -
!     all integrals for all operators under concideration for
!     given < 1, 2 | O | 3, 4>
!----------------------------------------------------------------------
      Use param_br, ONLY: isboef,isblk
      Implicit none
      Save
      Integer(4) :: nboef = 0       ! number of integrals
      Integer(4) :: mboef = 0       ! current dimension of list
      Integer(4) :: iboef = isboef  ! initial dimension
      Integer(4) :: jboef = 0       ! first new element
! ... IB_int(1:mboef) - integral indentifier
! ... boef(1:mboef) - correspondent angular coefficient
      Integer(4), Allocatable, Dimension(:) :: IB_int
      Real(8), Allocatable, Dimension(:) :: boef
      Integer(4) :: nblk  = 0       ! number of blocks
      Integer(4) :: mblk  = 0       ! current dimension of list
      Integer(4) :: iblk  = isblk   ! initial dimentsion
      Integer(4) :: kblk  = 0       ! block under consideration
! ... identifiers of block:
      Integer(4), Allocatable, Dimension(:) :: indl,indm,inds
! ... current identifiers:
      Integer(4) :: inl,inm,ins
! ... ncblk - pointer on the last element in the block
! ... ipblk - ordering pointer
      Integer(4), Allocatable, Dimension(:) :: ipblk,ncblk
      End MODULE BOEF_list
!======================================================================
      Subroutine alloc_boef(m)
!======================================================================
      Use inout_br, ONLY: nus,pri
      Use boef_list
      Implicit none
      Integer(4), Intent(in) :: m
      if(m.le.0) then
       if(allocated(IB_int)) Deallocate(IB_int,Boef);  mboef=0
      elseif(.not.allocated(IB_int)) then
       Allocate(IB_int(m), Boef(m));  mboef=m
      elseif(m.le.mboef) then
       Return
      elseif(nboef.eq.0) then
       Deallocate(IB_int,Boef)
       Allocate(IB_int(m), Boef(m));  mboef=m
      else
       Open(nus,status='SCRATCH',form='UNFORMATTED'); rewind(nus)
       write(nus) IB_int(1:nboef)
       write(nus) Boef(1:nboef)
       Deallocate(IB_int,Boef)
       Allocate(IB_int(m), Boef(m));  mboef=m
       rewind(nus)
       read(nus) IB_int(1:nboef)
       read(nus) Boef(1:nboef)
       Close(nus)
       write(*,*) 'realloc_boef: m = ', m
       write(pri,*) 'realloc_boef: m = ', m
      end if
      End Subroutine alloc_boef
!======================================================================
      Subroutine alloc_blk(m)
!======================================================================
      Use boef_list;  Use inout_br, ONLY: nus,pri
      Implicit none
      Integer(4), Intent(in) :: m
      if(m.le.0) then
       if(allocated(ipblk)) Deallocate(ipblk,ncblk,indl,indm,inds)
       mblk = 0; nblk = 0
      elseif(.not.allocated(ipblk)) then
       Allocate(ipblk(m),ncblk(m),indl(m),indm(m),inds(m)); mblk = m
      elseif(m.le.mblk) then
       Return
      elseif(nblk.eq.0) then
       Deallocate(ipblk,ncblk,indl,indm,inds)
       Allocate(ipblk(m),ncblk(m),indl(m),indm(m),inds(m)); mblk = m
      else
       Open(nus,status='SCRATCH',form='UNFORMATTED'); rewind(nus)
       write(nus) ipblk(1:nblk)
       write(nus) ncblk(1:nblk)
       write(nus) indl (1:nblk)
       write(nus) indm (1:nblk)
       write(nus) inds (1:nblk)
       Deallocate(ipblk,ncblk,indl,indm,inds)
       Allocate(ipblk(m),ncblk(m),indl(m),indm(m),inds(m)); mblk = m
       rewind(nus)
       read(nus) ipblk(1:nblk)
       read(nus) ncblk(1:nblk)
       read(nus) indl (1:nblk)
       read(nus) indm (1:nblk)
       read(nus) inds (1:nblk)
       Close(nus)
       write(*,*) 'realloc_blk: m,iblk = ', m,iblk
       write(pri,*) 'realloc_blk: m,iblk = ', m,iblk
      end if
      End Subroutine alloc_blk
!=======================================================================
      Subroutine Iadd_boef(C,int)
!=======================================================================
!
!     add new integral to the list 'boef'
!     (in the range of new block: jboef-nboef)
!
!-----------------------------------------------------------------------
      Use boef_list
      Implicit none
      Integer(4), Intent(in) :: int
      Real(8), Intent(in) :: C
      Integer(4) :: i
      if(mboef.eq.0) Call alloc_boef(iboef)
! ... check if the same itegral is already in the list:
      Do i=jboef,nboef
       if(int.ne.IB_int(i)) Cycle;  Boef(i)=Boef(i)+C; Return
      End do
! ... add new integral:
      if(nboef.eq.mboef) Call Alloc_boef(mboef+iboef)
      nboef=nboef+1; Boef(nboef)=C; IB_int(nboef)=int
      End Subroutine Iadd_boef
!=======================================================================
      Subroutine Check_boef(l1,m1,s1,l2,m2,s2,l3,m3,s3,l4,m4,s4)
!=======================================================================
!
!     Check if already there is the m.e. for given orbitals,
!     otherwise - calculate them.
!     Procedure use incoding the orbitals parameters, and that
!     restrict the max. l to 64 (see parameter jbm, jbl).
!     We can reduce this restriction  by using four identifiers
!     (instead three), one for each orbital.
!
!----------------------------------------------------------------------
      USE boef_list; USE param_br, ONLY: jbl,jbm
      Implicit none
      Integer(4), Intent(in) :: l1,m1,s1,l2,m2,s2,l3,m3,s3,l4,m4,s4
      Integer(4) :: i1,i2,i3,i4, k,l,m,ipm
! ... prepare indentifiers:
      i1 = jbm + m1; i2 = jbm + m2; i3 = jbm + m3; i4 = jbm + m4
      if(i1.ge.jbl.or.i2.ge.jbl.or.i3.ge.jbl.or.i4.ge.jbl) then
         write(*,'(a,3i5,3i10)') 'lms = ',l1,m1,s1,jbm,jbl,i1
         write(*,'(a,3i5,3i10)') 'lms = ',l2,m2,s2,jbm,jbl,i2
         write(*,'(a,3i5,3i10)') 'lms = ',l3,m3,s3,jbm,jbl,i3
         write(*,'(a,3i5,3i10)') 'lms = ',l4,m4,s4,jbm,jbl,i4
         Stop 'Check_boef: ml out of limits '
      end if
      inl = ((l1*jbl+l2)*jbl+l3)*jbl+l4
      inm = ((i1*jbl+i2)*jbl+i3)*jbl+i4
      ins = ((s1*jbl+s2)*jbl+s3)*jbl+s4
! ... look for the same case in the list:
      k=1; l = nblk
    1 if(k.gt.l) go to 2
      m=(k+l)/2; ipm=ipblk(m)
      if(inl.lt.indl(ipm)) then;      l = m - 1
      elseif(inl.gt.indl(ipm)) then;  k = m + 1
      else
      if(inm.lt.indm(ipm)) then;      l = m - 1
      elseif(inm.gt.indm(ipm)) then;  k = m + 1
      else
      if(ins.lt.inds(ipm)) then;      l = m - 1
      elseif(ins.gt.inds(ipm)) then;  k = m + 1
      else;   kblk = ipm;   Return
      end if; end if; end if
      go to 1
    2 Continue
! ... new block:
      jboef = nboef + 1
      Call ZNO_breit(1,l1,m1,s1,2,l2,m2,s2,3,l3,m3,s3,4,l4,m4,s4,+1)
      Call ZNO_breit(1,l1,m1,s1,2,l2,m2,s2,4,l4,m4,s4,3,l3,m3,s3,-1)
      nblk = nblk + 1;  ncblk(nblk) = nboef; kblk = nblk
      indl(nblk)=inl; indm(nblk)=inm; inds(nblk)=ins
      if(k.eq.nblk) then
       ipblk(k)=nblk
      else
       Do m = nblk,k+1,-1; ipblk(m) = ipblk(m-1); End do
       ipblk(k)=nblk
      end if
! ... it is time for re-allocation:
      if(nblk.eq.mblk) Call Alloc_blk(mblk+iblk)
      End Subroutine Check_boef


!====================================================================
      MODULE coef_list
!====================================================================
!
!     Contains a set of coefficients with two identifiers (intc,idfc)
!     The list of ordered according the pointer 'ipcoef'
!
!--------------------------------------------------------------------
      USE param_br, ONLY: iscoef
      IMPLICIT NONE
      SAVE
! ... number of coefficients:
      INTEGER(4) :: ncoef = 0
      INTEGER(4) :: mcoef = 0
      INTEGER(4) :: icoef = iscoef
      INTEGER(4) :: kcoef = 0
      INTEGER(4) :: ntotc = 0
      INTEGER(4) :: ntrm  = 0         !  number of terms
      INTEGER(4) :: mtrm  = 0
! ... coefficients (1:ntrm,1:mcoef):
      REAL(8),DIMENSION(:,:),ALLOCATABLE :: coef
      REAL(8),DIMENSION(:),ALLOCATABLE :: ctrm
! ... their attributes:
      INTEGER(4),DIMENSION(:),ALLOCATABLE :: intc,idfc,ijhm
! ... ordering pointer:
      INTEGER(4), Allocatable, Dimension(:) :: ipcoef
! ... current integral under consideration:
      INTEGER(4) :: int, idf, jcase
      End MODULE coef_list
!======================================================================
     Subroutine Alloc_coef(nt,mc)
!======================================================================
     USE coef_list
     USE inout_br, ONLY: nus, pri
     Implicit none
     Integer(4), Intent(in) :: nt,mc
     Integer(4) :: i
     if(nt.le.0.and.mc.gt.0) Stop ' Alloc_coef: nt = 0 '
     if(mc.le.0) then
      if(Allocated(coef)) &
       Deallocate(coef,intc,idfc,ipcoef,ctrm,ijhm)
       ncoef=0; mcoef=0; mtrm=0
     elseif(.not.Allocated(coef)) then
      Allocate(coef(nt,mc),intc(mc),idfc(mc),ipcoef(mc),&
               ctrm(nt),ijhm(nt)); mcoef=mc; mtrm=nt
     elseif(ncoef.le.0) then
      Deallocate(coef,intc,idfc,ipcoef,ctrm,ijhm)
      Allocate(coef(nt,mc),intc(mc),idfc(mc),ipcoef(mc),&
               ctrm(nt),ijhm(nt)); mcoef=mc; mtrm=nt
     elseif(ncoef.gt.0.and.(mc.gt.mcoef.or.nt.gt.mtrm)) then
      Open(nus,status='scratch',form='UNFORMATTED')
      rewind(nus)
      Do i = 1,mcoef
       write(nus) coef(1:mtrm,i)
       write(nus) intc(i)
       write(nus) idfc(i)
       write(nus) ipcoef(i)
      End do
      write(nus) ctrm(1:mtrm)
      write(nus) ijhm(1:mtrm)
      Deallocate(coef,intc,idfc,ipcoef,ctrm,ijhm)
      Allocate(coef(nt,mc),intc(mc),idfc(mc),ipcoef(mc),&
               ctrm(nt),ijhm(nt))
      rewind(nus)
      Do i = 1,mcoef
       read(nus) coef(1:mtrm,i)
       read(nus) intc(i)
       read(nus) idfc(i)
       read(nus) ipcoef(i)
      End do
      read(nus) ctrm(1:mtrm)
      read(nus) ijhm(1:mtrm)
      mcoef=mc; mtrm=nt
      write(*,*) ' realloc_coef: mcoef = ', mcoef,mtrm
      write(pri,*) ' realloc_coef: mcoef = ', mcoef,mtrm
     end if
	
     END Subroutine Alloc_coef
!======================================================================
      Subroutine Add_coef
!======================================================================
!
!     add new coefficient to the list
!
!----------------------------------------------------------------------
      USE coef_list
      Implicit none
      Integer(4) :: k,l,m,ipm
! ... look for the same integral in the list
      k=1; l = ncoef
    1 if(k.gt.l) go to 2
      m=(k+l)/2; ipm=ipcoef(m)
      if(int.lt.intc(ipm)) then;      l = m - 1
      elseif(int.gt.intc(ipm)) then;  k = m + 1
      else
       if(idf.lt.idfc(ipm)) then;     l = m - 1
       elseif(idf.gt.idfc(ipm)) then; k = m + 1
       else
        coef(1:ntrm,ipm) = coef(1:ntrm,ipm) + ctrm(1:ntrm)
        Return
       end if
      end if
      go to 1
    2 Continue
! ... new coefficient:
      ncoef = ncoef + 1
      coef(:,ncoef)=ctrm(:); intc(ncoef)=int; idfc(ncoef)=idf
      if(k.eq.ncoef) then
       ipcoef(k)=ncoef
      else
       Do m = ncoef,k+1,-1; ipcoef(m) = ipcoef(m-1); End do
       ipcoef(k)=ncoef
      end if
! ... it is time for relocation:
      if(ncoef.eq.mcoef) Call Alloc_coef (ntrm,mcoef+icoef)
      END Subroutine Add_coef


!----------------------------------------------------------------------
!
!     Modules for processing the overlap determinant:
!
!     DET_list,  alloc_det, Iadd_det
!     DEF_list,  alloc_def, Iadd_def
!
!     NDET_list,  alloc_ndet, Iadd_ndet
!     NDEF_list,  alloc_ndef, Iadd_ndef
!
!     NDET_IDET
!
!     DET_list and DEF_list contain the overlap determinants
!     and overlap factors for all configuration symmetries,
!     whereas NDET_list and NDEF_list contain this information
!     for two configuration under consideration.
!     These additional NDET, NDEF lists were introduced in hope
!     to reduce the seeking time in large common lists DET,DEF.
!
!     All four modules DET_list, DEF_list, NDET_list, NDEF_list
!     have the identical structure and  differ only by names
!     for variables.
!
!     The connection between DET,DEF and NDET,NDEF lists is given
!     by subroutine NDET_IDET.
!
!----------------------------------------------------------------------
!======================================================================
      MODULE DET_list
!======================================================================
!
!     Containes the overlap determinants for all config. symmetries.
!
!----------------------------------------------------------------------
      Use param_br, ONLY: isd,jsd
      Implicit none
      Save
      Integer(4) :: ndet = 0       ! number of determinants
      Integer(4) :: mdet = 0       ! current dimension of the list
      Integer(4) :: idet = isd     ! initial dimension
      Integer(4) :: jdet = jsd     ! average size of one det.
      Integer(4) :: kdet = 0       ! dimension of all det.s
      Integer(4), Allocatable, Dimension(:) :: KPD,IPD,NPD
      ! KPD(i) - dimension of i-th determinant
      ! IPD(i) - its pointer in common list NPD
      End MODULE DET_list
!======================================================================
      Subroutine alloc_det(m)
!======================================================================
      Use inout_br, ONLY: nus, pri, mrecl
      Use DET_list
      Implicit none
      Integer(4), Intent(in) :: m
      Integer(4) :: k
      if(m.le.0) then
       if(allocated(KPD)) Deallocate (KPD,IPD,NPD)
       mdet = 0; ndet = 0; kdet =0
      elseif(.not.allocated(KPD)) then
       mdet = m; kdet = mdet*jdet
       Allocate(KPD(mdet),IPD(mdet),NPD(kdet))
      elseif(m.le.mdet) then
       Return
      elseif(ndet.eq.0) then
       Deallocate (KPD,IPD,NPD)
       mdet = m; kdet = mdet*jdet
       Allocate(KPD(mdet),IPD(mdet),NPD(kdet))
      else
       Open(nus,status='SCRATCH',form='UNFORMATTED'); rewind(nus)
       Call W_i4(nus,mrecl,ndet,KPD)
       Call W_i4(nus,mrecl,ndet,IPD)
       Call W_i4(nus,mrecl,kdet,NPD)
       Deallocate (KPD,IPD,NPD)
       k=kdet; mdet = m; kdet = mdet*jdet
       Allocate(KPD(1:mdet),IPD(1:mdet),NPD(1:kdet))
       rewind(nus)
       Call R_i4(nus,mrecl,ndet,KPD)
       Call R_i4(nus,mrecl,ndet,IPD)
       Call R_i4(nus,mrecl,k   ,NPD)
       Close(nus)
       write(*,*) ' Realloc_det: new dimension = ', mdet,jdet
       write(pri,*) ' Realloc_det: new dimension = ', mdet,jdet
      end if
      End Subroutine alloc_DET
!----------------------------------------------------------------------
      Integer(4) Function Iadd_det (kd,NP)
!----------------------------------------------------------------------
!
!     add new overlap determinant to DET_list
!
!----------------------------------------------------------------------
      Use det_list
      Implicit none
      Integer(4) , Intent(in) :: kd
      Integer(4) , Intent(in), Dimension(kd) :: NP
      Integer(4) :: i,j,ip
      Iadd_det = 0
      if(kd.le.0) Return
      if(mdet.eq.0) Call Alloc_DET(idet)
! ... check if the same det. is already in the list:
      Do i=1,ndet
       if(KPD(i).ne.kd) Cycle
       ip=IPD(i); Iadd_det = i
       Do j=1,kd
        if(NP(j).eq.NPD(ip+j)) Cycle; Iadd_det = 0; Exit
       End do
       if(Iadd_det.ne.0) Return
      End do
! ... Add new det.:
      ndet=ndet+1; ip=0; if(ndet.gt.1) ip=IPD(ndet-1)+KPD(ndet-1)
      if(ndet.eq.mdet.or.ip+kd.gt.kdet) then
       jdet = kdet/ndet + 1; Call Alloc_det(mdet+idet)
      end if
      KPD(ndet)=kd; IPD(ndet)=ip; NPD(ip+1:ip+kd)=NP(1:kd)
      Iadd_det=ndet
      End Function Iadd_det
!======================================================================
      MODULE DEF_list
!======================================================================
!
!     Containes the overlap factors, as the list of the number of
!     involved overlap determinants and their positions in the
!     common det_list.
!
!     KPF(i) - number of det.s in i-th overlap factor
!     IPF(i) - pointer on the list of corr. det.s in the NPF
!     NPF(ip+1:ip+kd) - list of pointers on det.s in the DET_list
!                       and their powers
!----------------------------------------------------------------------
      Use param_br, ONLY: isf,jsf
      Implicit none
      Save
      Integer(4) :: ndef = 0       ! number of determinants
      Integer(4) :: mdef = 0       ! current dimentsion of list
      Integer(4) :: idef = isf     ! supposed max. dimentsion
      Integer(4) :: jdef = jsf     ! average number of det.s
      Integer(4) :: kdef = 0       ! dimension of all def.s
      Integer(4), Allocatable, Dimension(:) :: KPF,IPF,NPF
      End MODULE DEF_list
!======================================================================
      Subroutine alloc_def(m)
!======================================================================
      USE def_list
      Use inout_br, ONLY: nus, pri, mrecl
      Implicit none
      Integer(4), Intent(in) :: m
      Integer(4) :: k
      if(m.le.0) then
       if(allocated(KPF)) Deallocate(KPF,IPF,NPF)
       mdef = 0; ndef = 0; kdef = 0
      elseif(.not.allocated(KPF)) then
       mdef = m; kdef = mdef*jdef
       Allocate(KPF(mdef),IPF(mdef),NPF(kdef))
      elseif(m.le.mdef) then
       Return
      elseif(ndef.eq.0) then
       Deallocate (KPF,IPF,NPF)
       mdef = m; kdef = mdef*jdef
       Allocate(KPF(mdef),IPF(mdef),NPF(kdef))
      else
       Open(nus,status='SCRATCH',form='UNFORMATTED'); rewind(nus)
       Call W_i4(nus,mrecl,ndef,KPF)
       Call W_i4(nus,mrecl,ndef,IPF)
       Call W_i4(nus,mrecl,kdef,NPF)
       Deallocate (KPF,IPF,NPF)
       k=kdef; mdef = m; kdef = mdef*jdef
       Allocate(KPF(mdef),IPF(mdef),NPF(kdef))
       rewind(nus)
       Call R_i4(nus,mrecl,ndef,KPF)
       Call R_i4(nus,mrecl,ndef,IPF)
       Call R_i4(nus,mrecl,k   ,NPF)
       Close(nus)
       write(*,*) ' Realloc_def: new dimension = ', mdef,jdef,ndef
       write(pri,*) ' Realloc_def: new dimension = ', mdef,jdef,ndef
      end if
      End Subroutine alloc_def
!----------------------------------------------------------------------
      Integer(4) Function Iadd_def (kd,NP)
!----------------------------------------------------------------------
!
!     add new overlap factor to DEF_list
!
!     kd    - number of det.s
!     NP(i) - pointer for the i-th det.
!
!----------------------------------------------------------------------
      USE def_list
      Implicit none
      Integer(4) , Intent(in) :: kd
      Integer(4) , Dimension(kd) :: NP
      Integer(4) :: i,j,ip
      if(kd.le.0) Return
      if(mdef.eq.0) Call Alloc_def(idef)
! ... check: is the same def. in the list:
      Do i=1,ndef
       if(KPF(i).ne.kd) Cycle
       ip=IPF(i); Iadd_def = i
       Do j=1,kd
        if(NP(j).eq.NPF(ip+j)) Cycle; Iadd_def = 0; Exit
       End do
       if(Iadd_def.ne.0) Return
      End do
! ... Add new def.:
      ndef=ndef+1; ip=0; if(ndef.gt.1) ip=IPF(ndef-1)+KPF(ndef-1)
      if(ndef.eq.mdef.or.ip+kd.gt.kdef) then
       jdef = (ip+kd)/ndef + 1; Call Alloc_def(mdef+idef)
      end if
      KPF(ndef)=kd; IPF(ndef)=ip; NPF(ip+1:ip+kd)=NP(1:kd)
      Iadd_def=ndef
      End Function Iadd_def
!======================================================================
      MODULE NDET_list
!======================================================================
!
!     Containes the overlap determinants for two config. symmetries
!     under consideration
!
!----------------------------------------------------------------------
      Use param_br, ONLY: isd,jsd
      Implicit none
      Save
      Integer(4) :: ndet = 0       ! number of determinants
      Integer(4) :: mdet = 0       ! current dimentsion of list
      Integer(4) :: idet = isd     ! supposed max. dimentsion
      Integer(4) :: jdet = jsd     ! average size of one det.
      Integer(4) :: kdet = 0       ! dimension of all det.s
      Integer(4), Allocatable, Dimension(:) :: KPD,IPD,NPD
      End MODULE NDET_list
!======================================================================
      Subroutine alloc_ndet(m)
!======================================================================
      Use inout_br, ONLY: nus, pri, mrecl
      Use NDET_list
      Implicit none
      Integer(4), Intent(in) :: m
      Integer(4) :: k
      if(m.le.0) then
       if(allocated(KPD)) Deallocate (KPD,IPD,NPD)
       mdet = 0; ndet = 0; kdet =0
      elseif(.not.allocated(KPD)) then
       mdet = m; kdet = mdet*jdet
       Allocate(KPD(mdet),IPD(mdet),NPD(kdet))
      elseif(m.le.mdet) then
       Return
      elseif(ndet.eq.0) then
       Deallocate (KPD,IPD,NPD)
       mdet = m; kdet = mdet*jdet
       Allocate(KPD(mdet),IPD(mdet),NPD(kdet))
      else
       Open(nus,status='SCRATCH',form='UNFORMATTED'); rewind(nus)
       Call W_i4(nus,mrecl,ndet,KPD)
       Call W_i4(nus,mrecl,ndet,IPD)
       Call W_i4(nus,mrecl,kdet,NPD)
       Deallocate (KPD,IPD,NPD)
       k=kdet; mdet = m; kdet = mdet*jdet
       Allocate(KPD(1:mdet),IPD(1:mdet),NPD(1:kdet))
       rewind(nus)
       Call R_i4(nus,mrecl,ndet,KPD)
       Call R_i4(nus,mrecl,ndet,IPD)
       Call R_i4(nus,mrecl,k   ,NPD)
       Close(nus)
       write(*,*) ' realloc_ndet: new dimension = ', mdet,kdet
       write(pri,*) ' realloc_ndet: new dimension = ', mdet,kdet
      end if
      End Subroutine alloc_NDET
!----------------------------------------------------------------------
      Integer(4) Function Nadd_det (kd,NP)
!----------------------------------------------------------------------
!
!     add the overlap determinant to NDET_list
!
!----------------------------------------------------------------------
      Use ndet_list
      Implicit none
      Integer(4) , Intent(in) :: kd
      Integer(4) , Intent(in), Dimension(kd) :: NP
      Integer(4) :: i,j,ip
      Nadd_det = 0
      if(kd.le.0) Return
      if(mdet.eq.0) Call Alloc_NDET(idet)
! ... check: is the same det. in the list:
      Do i=1,ndet
       if(KPD(i).ne.kd) Cycle
       ip=IPD(i); Nadd_det = i
       Do j=1,kd
        if(NP(j).eq.NPD(ip+j)) Cycle; Nadd_det = 0; Exit
       End do
       if(Nadd_det.ne.0) Return
      End do
! ... Add new det.:
      ndet=ndet+1; ip=0; if(ndet.gt.1) ip=IPD(ndet-1)+KPD(ndet-1)
      if(ndet.eq.mdet.or.ip+kd.gt.kdet) then
       jdet = (ip+kd)/ndet + 1; Call Alloc_ndet(mdet+idet)
      end if
      KPD(ndet)=kd; IPD(ndet)=ip; NPD(ip+1:ip+kd)=NP(1:kd)
      Nadd_det=ndet
      End Function Nadd_det
!======================================================================
      MODULE NDEF_list
!======================================================================
!
!     Containes the overlap factors, as the list of the number of
!     involved overlap determinants and their positions in the
!     common det_list.
!
!     KPF(i) - number of det.s in the overlap factor 'i'  (kd)
!     IPF(i) - pointer on the list of corr. det.s in the NPF  (ip)
!     NPF(ip+1:ip+kd) - list of pointers on det.s in the det_list
!                       and their powers
!----------------------------------------------------------------------
      Use param_br, ONLY: isf,jsf
      Implicit none
      Save
      Integer(4) :: ndef = 0       ! number of determinants
      Integer(4) :: mdef = 0       ! current dimentsion of list
      Integer(4) :: idef = isf     ! supposed max. dimentsion
      Integer(4) :: jdef = jsf     ! average number of det.s
      Integer(4) :: kdef = 0       ! dimension of all def.s
      Integer(4), Allocatable, Dimension(:) :: KPF,IPF,NPF
      End MODULE NDEF_list
!======================================================================
      Subroutine alloc_ndef(m)
!======================================================================
      USE ndef_list
      Use inout_br, ONLY: nus, pri, mrecl
      Implicit none
      Integer(4), Intent(in) :: m
      Integer(4) :: k
      if(m.le.0) then
       if(allocated(KPF)) Deallocate(KPF,IPF,NPF)
       mdef = 0; ndef = 0; kdef = 0
      elseif(.not.allocated(KPF)) then
       mdef = m; kdef = mdef*jdef
       Allocate(KPF(mdef),IPF(mdef),NPF(kdef))
      elseif(m.le.mdef) then
       Return
      elseif(ndef.eq.0) then
       Deallocate (KPF,IPF,NPF)
       mdef = m; kdef = mdef*jdef
       Allocate(KPF(mdef),IPF(mdef),NPF(kdef))
      else
       Open(nus,status='SCRATCH',form='UNFORMATTED'); rewind(nus)
       Call W_i4(nus,mrecl,ndef,KPF)
       Call W_i4(nus,mrecl,ndef,IPF)
       Call W_i4(nus,mrecl,kdef,NPF)
       Deallocate (KPF,IPF,NPF)
       k=kdef; mdef = m; kdef = mdef*jdef
       Allocate(KPF(mdef),IPF(mdef),NPF(kdef))
       rewind(nus)
       Call R_i4(nus,mrecl,ndef,KPF)
       Call R_i4(nus,mrecl,ndef,IPF)
       Call R_i4(nus,mrecl,k   ,NPF)
       Close(nus)
       write(*,*) ' Realloc_ndef: new dimension = ', mdef,jdef
       write(pri,*) ' Realloc_ndef: new dimension = ', mdef,jdef
      end if
      End Subroutine alloc_ndef
!----------------------------------------------------------------------
      Integer(4) Function Nadd_def (kd,NP)
!----------------------------------------------------------------------
!
!     add the overlap factor to def_list
!
!     kd    - number of det.s
!     NP(i) - pointer for the i-th det.
!
!----------------------------------------------------------------------
      USE ndef_list
      Implicit none
      Integer(4) , Intent(in) :: kd
      Integer(4) , Dimension(kd) :: NP
      Integer(4) :: i,j,ip
      if(kd.le.0) Return
      if(mdef.eq.0) Call Alloc_ndef(idef)
! ... check: is the same def. in the list:
      Do i=1,ndef
       if(KPF(i).ne.kd) Cycle
       ip=IPF(i); Nadd_def = i
       Do j=1,kd
        if(NP(j).eq.NPF(ip+j)) Cycle; Nadd_def = 0; Exit
       End do
       if(Nadd_def.ne.0) Return
      End do
! ... Add new def.:
      ndef=ndef+1; ip=0; if(ndef.gt.1) ip=IPF(ndef-1)+KPF(ndef-1)
      if(ndef.eq.mdef.or.ip+kd.gt.kdef) then
       jdef = kdef/ndef + 1; Call Alloc_ndef(mdef+idef)
      end if
      KPF(ndef)=kd; IPF(ndef)=ip; NPF(ip+1:ip+kd)=NP(1:kd)
      Nadd_def=ndef
      End Function Nadd_def
!======================================================================
     Subroutine Ndet_Idet
!======================================================================
!
!    Convert NDET and NDEF lists to the common DET and DEF lists.
!    Connection is given in IPF array.
!    The NDET and NDEF lists are then nulefied.
!
!----------------------------------------------------------------------
      Use NDET_list
      Use NDEF_list
      Use param_br, ONLY: ibf
      USE spin_orbitals, ONLY: NP
      IMPLICIT NONE
      Integer(4) :: i,j,ip,jp,id,kd,ns
      Integer(4), External :: Iadd_det, Iadd_def, ISORT
      if(ndet.le.0) Stop ' NDET_IDET: ndet <= 0'
      Do id=1,ndet
       kd=KPD(id); ip=IPD(id); NP(1:kd)=NPD(ip+1:ip+kd)
       IPD(id) = Iadd_det(kd,NP)
      End do
      ndet = 0
      if(ndef.le.0) Stop ' NDET_IDET: ndef <= 0'
      Do id=1,ndef
       kd=KPF(id); ip=IPF(id)
       Do i=1,kd
        j=NPF(ip+i)/ibf; jp=IPD(j); ns=mod(NPF(ip+i),ibf)
        NP(i) = jp*ibf + ns
       End do
       i = ISORT (kd,NP)
       IPF(id) = Iadd_def (kd,NP)
      End do
      ndef = 0
      End Subroutine Ndet_Idet


!======================================================================
      MODULE inter
!======================================================================
!
!     define the interaction matrix elements under consideration
!
!     noper     - number of different operators
!     ioper(:)  - pointer on the required operators
!     joper(:)  - pointer on the operator under current consideration
!
!     IT_oper(:,:) - pointer on the done calculation for specific
!                    operators and given terms
!     JT_oper(:,:) - pointer on the required operators for given
!                    subset of term between two configurations
!
!     IC_need(:)   - define the need of calc. for two given config.s
!     JC_need(:)   - define the need of calc. for the given config.
!
!-----------------------------------------------------------------------
      USE configs, only: nsh
      IMPLICIT NONE
      SAVE
      Integer(4), parameter :: noper = 7
      Integer(1) ioper(noper)/1,1,1,0,0,0,0/, joper(noper)
      Real(8) :: coper(noper)
!     Operator(1)   -   overlaps
!     Operator(2)   -   kinatic energy
!     Operator(3)   -   two-electron electrostatic
!     Operator(4)   -   spin-orbit
!     Operator(5)   -   spin-other-orbit
!     Operator(6)   -   spin-spin
!     Operator(7)   -   orbit-orbit
      Integer(1), Allocatable, Dimension(:,:) :: IT_oper
      Integer(1), Allocatable, Dimension(:,:) :: JT_oper
      Integer(4), Allocatable, Dimension(:) :: IC_need
      Integer(4), Allocatable, Dimension(:) :: JC_need
! ... configurations under consideration:
      Integer(4) :: ic,jc
! ... number of different (CONFIG or ML,MS) cases :
      Integer(4) :: ic_case
      Real(8), Allocatable, Dimension(:,:) :: CT_oper
! ... list of total LS:
      Integer(4), Allocatable, Dimension(:) :: ILT_ic, IST_ic
      Integer(4) :: nzero=0  ! not used at the moment
      End MODULE inter
!=====================================================================
!  following procedures control of the done calculations and the need
!  of additional calculations for specific operators and configuration:
!
!  Idef_cme        -  defines required operators for config.s ic,jc
!  IT_CALC (it,jt) -  defines need of calc. for terms it,jt
!  IC_CALC (ic,jc) -  defines need of calc. for config.s ic,jc
!  DEF_IC (it,jt)  -  record what has been done for config.s ic,jc
!
!=====================================================================
!=====================================================================
      Integer(4) Function Idef_cme()
!=====================================================================
!
!     define the operators to be considered for given configurations
!     from module 'term_exp': ioper + IT_oper -> joper + JT_oper
!
!---------------------------------------------------------------------
      USE inter; USE term_exp; USE coef_list, Only: ntrm
      Implicit none
      Integer(4) :: it,jt,ik,jk, i,j,ij, k
       k = 0
       Do ik=1,kt1;  it=IP_kt1(ik)
       Do jk=1,kt2;  jt=IP_kt2(jk)
        i=max(it,jt); j=min(it,jt); ij = i*(i-1)/2+j
        Do i=1,noper
         joper(i) = 0
         if(ioper(i).gt.IT_oper(i,ij)) joper(i)=ioper(i)
        End do
        if(ic.eq.jc.and.it.gt.jt) Cycle;  k = k + 1
        JT_oper(k,:) = joper(:)
       End do
       End do
       joper = 0
       Do i = 1,noper
        Do it=1,ntrm
         if(JT_oper(it,i).eq.0) Cycle; joper(i) = 1; Exit
        End do
       End do
       IDEF_cme = 0
       Do i=1,noper
        if(joper(i).eq.0) Cycle; IDEF_cme=1; Exit
       End do
      End function IDEF_cme
!=====================================================================
      Integer(4) Function IT_calc (it,jt)
!=====================================================================
!
!     determine the need of additional calculation between two terms
!     (then IT_calc=1)
!
!---------------------------------------------------------------------
      USE inter;   USE configs, ONLY: IT_stat
      Implicit none
      Integer(4), Intent(in) :: it,jt
      Integer(4) :: i,j,ij
      IT_calc = 0
! ... are there such states ?
      if(IT_stat(it)*IT_stat(jt).eq.0) Return
! ... already done ?
      i=max(it,jt); j=min(it,jt); ij = i*(i-1)/2+j
      Do i=1,noper
       if(ioper(i).gt.IT_oper(i,ij)) IT_calc = 1
      End do
      End Function IT_calc
!=====================================================================
      Integer(4) Function IC_calc (is,js)
!=====================================================================
!
!     determine the need (then IC_calc = 1) of additional calculation
!     between two configurations is and js
!
!--------------------------------------------------------------------
      USE configs, ONLY: IC_term, IP_term, ibc
      Implicit none
      Integer(4), Intent(in) :: is,js
      Integer(4) :: it,jt,ik,jk,it1,it2,jt1,jt2
      Integer(4), External :: IT_calc
      IC_calc=0
      it=IC_term(is); it1=mod(it,ibc); it2=it/ibc
      Do ik=it1,it2;  it=IP_term(ik)
       jt=IC_term(js); jt1=mod(jt,ibc); jt2=jt/ibc
       Do jk=jt1,jt2;  jt=IP_term(jk)
         IC_calc = IT_calc (it,jt); if(IC_calc.eq.1) Return
        End do
       End do
      End Function IC_calc
!=====================================================================
       Subroutine DEF_IC (is,js)
!=====================================================================
!
!      record what has been done for given config.s is,js
!
!---------------------------------------------------------------------
       USE inter; Use configs
       Implicit none
       Integer(4), Intent(in) :: is,js
       Integer(4) :: i,j,ij,it,jt,ik,jk,it1,it2,jt1,jt2
       it=IC_term(is); it1=mod(it,ibc); it2=it/ibc
       Do ik=it1,it2;  it=IP_term(ik)
        if(IT_stat(it).eq.0) Cycle
       jt=IC_term(js); jt1=mod(jt,ibc); jt2=jt/ibc
       Do jk=jt1,jt2;  jt=IP_term(jk)
        if(IT_stat(jt).eq.0) Cycle
        i=max(it,jt); j=min(it,jt); ij = i*(i-1)/2+j
        Do i = 1,noper
         if(ioper(i).gt.IT_oper(i,ij)) IT_oper(i,ij)=ioper(i)
        End do
       End do; End do
       End Subroutine DEF_IC


!======================================================================
      MODULE ZOEF_list
!======================================================================
!
!     Containes the coefficients for two configuration symmetries.
!     Each coefficient has two identifiers: iz_int and ia_df,
!     the pointers for integral and overlap factor, respectively.
!
!----------------------------------------------------------------------
      Use param_br, ONLY: iszoef
      Implicit none
      Save
      Integer(4) :: nzoef = 0       ! number of coefficients
      Integer(4) :: mzoef = 0       ! current dimentsion of the list
      Integer(4) :: izoef = iszoef  ! initial dimension
      Integer(4), Allocatable, Dimension(:) :: IZ_int,IZ_df
      Real(8), Allocatable, Dimension(:) :: Zoef
      End MODULE ZOEF_list
!======================================================================
      Subroutine alloc_zoef(m)
!======================================================================
      Use inout_br, ONLY: nus, pri
      Use zoef_list
      Implicit none
      Integer(4), Intent(in) :: m
      if(m.le.0) then
       if(allocated(IZ_int)) Deallocate(IZ_int,IZ_DF,Zoef);  mzoef=0
      elseif(.not.allocated(IZ_int)) then
       Allocate(IZ_int(m), IZ_DF(m), Zoef(m));  mzoef=m
      elseif(m.le.mzoef) then
       Return
      elseif(nzoef.eq.0) then
       Deallocate(IZ_int,IZ_DF,Zoef)
       Allocate(IZ_int(m), IZ_DF(m), Zoef(m));  mzoef=m
      else
       Open(nus,status='SCRATCH',form='UNFORMATTED'); rewind(nus)
       write(nus) IZ_int(1:nzoef)
       write(nus) IZ_DF(1:nzoef)
       write(nus) Zoef(1:nzoef)
       Deallocate(IZ_int,IZ_DF,Zoef)
       Allocate(IZ_int(m), IZ_DF(m), Zoef(m));  mzoef = m
       rewind(nus)
       read(nus) IZ_int(1:nzoef)
       read(nus) IZ_DF(1:nzoef)
       read(nus) Zoef(1:nzoef)
       Close(nus)
       write(*,*) ' realloc_zoef: m = ', m
       write(pri,*) ' realloc_zoef: m = ', m
      end if
      End Subroutine alloc_zoef
!=======================================================================
      Subroutine Iadd_zoef(C,int,idf)
!=======================================================================
!
!     add new integral to the list 'zoef'
!
!-----------------------------------------------------------------------
      Use zoef_list
      Implicit none
      Integer(4), Intent(in) :: int,idf
      Real(8), Intent(in) :: C
      Integer(4) :: i
      if(mzoef.eq.0) Call Alloc_zoef(izoef)
! ... check if the same integral is already in list:
      Do i=1,nzoef
       if(int.ne.IZ_int(i)) Cycle
       if(idf.ne.IZ_DF(i)) Cycle
       Zoef(i)=Zoef(i)+C; Return
      End do
! ... add new integral:
      if(nzoef.eq.mzoef) Call Alloc_zoef(mzoef+izoef)
      nzoef = nzoef+1
      Zoef(nzoef)=C; IZ_int(nzoef)=int; IZ_DF(nzoef)=idf
      End Subroutine Iadd_zoef


!======================================================================
      Subroutine Add_res(nu)
!======================================================================
!
!     records results from 'coef_list' to unit 'nu'
!
!----------------------------------------------------------------------
      USE param_br;  USE inter;  USE coef_list;  USE term_exp
      USE ndef_list, ONLY: IPF
      USE configs, ONLY: ibc
      Implicit none
      Integer(4), Intent(in) :: nu
      Integer(4) :: i,j, it,jt, k,k1,k2, nc
! ... convert det.factors from ndef_list to common list:
      Call Ndet_Idet
      Do i=1,ncoef
       if(idfc(i).eq.0) Cycle
       j = idfc(i); idfc(i) = IPF(j)
      End do
! ... define the term poiners:
      k = 0
      Do k1=1,kt1; it=IP_kt1(k1)
      Do k2=1,kt2; jt=IP_kt2(k2)
       if(ic.eq.jc.and.it.gt.jt) Cycle
       k = k + 1;  ijhm(k) = it*ibc+jt
      End do; End do
      if(k.ne.ntrm) Stop 'Add_res: ij <> ntrm'
! ... record the coef.s:
      nc = 0
      Do i = 1,ntrm
       Do j = 1,ncoef
        if(abs(coef(i,j)).lt.Eps_C) Cycle
        write(nu) coef(i,j),ijhm(i),intc(j),idfc(j)
        nc=nc+1
       End do
      End do
      ntotc = ntotc + nc
      End Subroutine Add_res


!======================================================================
      Subroutine Conf_loop
!======================================================================
!
!     run loop over configurations
!
!-----------------------------------------------------------------------
      USE param_br; USE configs; USE inter; USE spin_orbitals
      USE term_exp; USE coef_list; USE zoef_list; Use boef_list
      USE inout_br
      Implicit none
      Integer(4) :: i,j,k,l,m,k1,k2,is,js, it,jt, ij, MLT2,MST2
      Integer(4), External :: ML_id, MS_id, Iglq,IDEF_cme
      Real(8) :: t1,t2,tt, C_ee,C_so,C_ss, zero=0.d0, one=1.d0
      Real(8), External :: RRTC, Z_3j
!----------------------------------------------------------------------
!                                         define possible mls orbitals:
      m = 0
      Do is = 1,nsymt
       Do i=1,noccsh(is)
        l = nocorb(i,is); if(l.gt.m) m = l
       End do
      End do
      mls_max = 4*m + 2
      if(Allocated(ml_orb)) Deallocate(ml_orb,ms_orb)
      Allocate(ml_orb(mls_max), ms_orb(mls_max))
      Do i = 1,mls_max
       ml_orb(i)=ML_id(i)
       ms_orb(i)=MS_id(i)
      End do
!----------------------------------------------------------------------
!                                                          allocations:
      if(.not.Allocated(Lsym)) then
       m = 2*ne
       Allocate(Lsym(m),Lsym1(m),Lsym2(m),  &
                Msym(m),Msym1(m),Msym2(m),  &
                Ssym(m),Ssym1(m),Ssym2(m),  &
                IPsym1(m),IPsym2(m),Ksym1(m),Ksym2(m), &
                nnsym1(m),nnsym2(m),Isym1(m),Isym2(m)  )
       Allocate(N1(m),N2(m),N3(m),N4(m),NP(m))
      end if
!----------------------------------------------------------------------
!                                          cycle 1 over configurations:
      rewind(nud)
      Do is=1,ic_case
       Read(nud) ic,kt1,kdt1,ILT1,IST1,MLT,MST
       if(Allocated(IP_kt1)) Deallocate(IP_kt1)
       Allocate(IP_kt1(kt1)); Read(nud) IP_kt1
       if(Allocated(IP_det1)) Deallocate(IP_det1)
       Allocate(IP_det1(ne,kdt1)); Read(nud) IP_det1
       if(Allocated(C_det1)) Deallocate(C_det1)
       Allocate(C_det1(kt1,kdt1)); Read(nud) C_det1
       if(IC_need(ic).eq.0) Cycle
       it = IP_kt1(1); no1=noccsh(it); k=1
       Do i=1,no1
        ln1(i)=nocorb(i,it); iq1(i)=nelcsh(i,it)
        Do j=k,k+iq1(i)-1
         NNsym1(j)=i; Lsym1 (j)=ln1(i)
        End do
        k=k+iq1(i)
       End do
       Call Pri_conn(no1,ln1,iq1,CONFIG)
       write(*,'(a,4i8,a)') ' ic =',ic,nsymc,kt1,kdt1,CONFIG(1:8*no1)
       write(pri,'(a,4i8,a)') ' ic =',ic,nsymc,kt1,kdt1,CONFIG(1:8*no1)
       t1=RRTC()
!----------------------------------------------------------------------
!                                          cycle 2 over configurations:
      rewind(nud)
      Do js=1,is
       Read(nud) jc,kt2,kdt2,ILT2,IST2,MLT2,MST2
       if(Allocated(IP_kt2)) Deallocate(IP_kt2)
       Allocate(IP_kt2(kt2)); Read(nud) IP_kt2
       if(Allocated(IP_det2)) Deallocate(IP_det2)
       Allocate(IP_det2(ne,kdt2)); Read(nud) IP_det2
       if(Allocated(C_det2)) Deallocate(C_det2)
       Allocate(C_det2(kt2,kdt2)); Read(nud) C_det2
       if(MLT2.ne.MLT.or.MST2.ne.MST) Cycle
!cd
       if(MLT.ne.min(ILT1,ILT2).or.MST.ne.min(IST1,IST2)) Cycle
       i = max(ic,jc); j = min(ic,jc); ij = i*(i-1)/2 + j
       if(JC_need(ij).eq.0) Cycle
       jt=IP_kt2(1); no2=noccsh(jt); k=1
       Do i=1,no2
        ln2(i)=nocorb(i,jt); iq2(i)=nelcsh(i,jt)
        Do j=k,k+iq2(i)-1
         NNsym2(j)=i; Lsym2 (j)=ln2(i)
        End do
        k=k+iq2(i)
       End do
!       ILT2 = ILT_ic(jc); IST2 = IST_ic(jc)
!----------------------------------------------------------------------
!                                               define number of terms:
       ntrm = 0
       Do k1=1,kt1; it=IP_kt1(k1)
       Do k2=1,kt2; jt=IP_kt2(k2)
        if(ic.eq.jc.and.it.gt.jt) Cycle;  ntrm = ntrm + 1
       End do; End do
       if(allocated(JT_oper)) Deallocate(JT_oper,CT_oper)
       Allocate(JT_oper(ntrm,noper),CT_oper(ntrm,noper))
!----------------------------------------------------------------------
       if(IDEF_cme().eq.0) then
        Call DEF_IC(ic,jc); Cycle
       end if
!----------------------------------------------------------------------
       ncoef=0; Call Alloc_coef(ntrm,icoef)
       nboef=0; Call Alloc_boef(iboef)
       nblk=0;  Call Alloc_blk(iblk)
!----------------------------------------------------------------------
! ... define the normalization constants for different operators:
       C_so = zero
       if(joper(4)+joper(5).ne.0) &
        C_so = Z_3j(ILT1,-MLt+2,3,1,ILT2,MLt)* &
               Z_3j(IST1,-MSt+2,3,1,IST2,MSt)* &
               (-1)**((ILT1-MLt+IST1-MSt)/2)
       if(C_so.ne.zero) C_so=one/C_so
       C_ss = zero
       if(joper(6).ne.0) &
        C_ss = Z_3j(ILT1,-MLt+2,5,1,ILT2,MLt)* &
               Z_3j(IST1,-MSt+2,5,1,IST2,MSt)* &
               (-1)**((ILT1-MLt+IST1-MSt)/2)
       if(C_ss.ne.zero) C_ss=one/C_ss
       C_ee = one; if(ILT1.ne.ILT2.or.IST1.ne.IST2) C_ee = zero
       if((C_ee + C_so + C_ss) .eq. zero) Cycle
       coper(1) = zero; if(joper(1).gt.0) coper(1) = C_ee
       coper(2) = zero; if(joper(2).gt.0) coper(2) = C_ee
       coper(3) = zero; if(joper(3).gt.0) coper(3) = C_ee
       coper(4) = zero; if(joper(4).gt.0) coper(4) = C_so
       coper(5) = zero; if(joper(5).gt.0) coper(5) = C_so
       coper(6) = zero; if(joper(6).gt.0) coper(6) = C_ss
       coper(7) = zero; if(joper(7).gt.0) coper(7) = C_ee
!----------------------------------------------------------------------
! ...  calculations:
       Do kd1 = 1,kdt1
        Do i=1,ne
          m = IP_det1(i,kd1)
          Msym1(i)=(ML_orb(m)-1)/2; Ssym1(i)=MS_orb(m)
        End do
       Do kd2 = 1,kdt2
        Do i=1,ne
          m = IP_det2(i,kd2)
          Msym2(i)=(ML_orb(m)-1)/2; Ssym2(i)=MS_orb(m)
        End do
        Call Det_breit
        if(nzoef.gt.0) Call Term_loop
       End do;  End do
!----------------------------------------------------------------------
! ...  store results for given config.s:
       if(ncoef.gt.0) Call Add_res(nui); Call DEF_IC(ic,jc)
      End do    ! over jc
      t2=RRTC();  tt=t2-t1
      if(tt.gt.100) write(pri,'(a,F12.2,a)') ' time: ',tt,' sec.'
      if(tt.gt.100) write(*,'(a,F12.2,a)') ' time: ',tt,' sec.'
      End do    ! over ic
      Do ic=1,nsymc;  Do jc=1,ic; Call DEF_IC(ic,jc); End do; End do
      End Subroutine Conf_loop
!======================================================================
      Subroutine Pri_conn (n,ln,iq,CONFIG)
!======================================================================
!
!     gives the configuration without terms
!
!----------------------------------------------------------------------
      Character(*) :: CONFIG
      Character(4), External :: ELF4
      Integer(4), Intent(in) :: n
      Integer(4), Intent(in), Dimension(n) :: ln,iq
      Integer(4) :: k,i,ii
      ii = LEN_TRIM(CONFIG)
      Do i=1,ii;  Config(i:i)=' ';  End do
      k=1
      Do i=1,n
       write(CONFIG(k:k+7),'(a4,''('',i2,'')'')') &
             ELF4(0,ln(i),0),iq(i)
       k=k+8
      End do
      End Subroutine Pri_conn


!======================================================================
      Subroutine DET_breit
!======================================================================
!
!     creates the common list of orbital symmetries for two input
!     determinants and call the subroutines for calculations of
!     coefficients between possible combinations of symmetries
!
!----------------------------------------------------------------------
      USE inter;  USE spin_orbitals;   USE configs, ONLY: ne
      Implicit none
      Integer(4) :: i,i1,i2, j,j1,j2, k,k1,k2
      Integer(4), External :: Isort
!----------------------------------------------------------------------
!                              creat common list of orbital symmetries:
      ksym1=1; ksym2=1
      NSYM = 0; k1 = 0;  k2 = 0; kz1=0; kz2=0
! ... exzaust the 1-st configuration:
      Do i = 1,ne
       if(ksym1(i).eq.0) Cycle
       Nsym = Nsym + 1
       Lsym(Nsym)=Lsym1(i); Msym(Nsym)=Msym1(i); Ssym(Nsym)=Ssym1(i)
       k1=k1+1; IPsym1(Nsym)=k1; Isym1(k1)=i; ksym1(i)=0
!       kz1 = kz1 + (i-k1)  ! cd
! ... check for the same orbitals rest the 1-st configuration:
       Do j = i+1,ne
        if(ksym1(j).eq.0) Cycle
        if(Lsym(Nsym).ne.Lsym1(j)) Cycle
        if(Msym(Nsym).ne.Msym1(j)) Cycle
        if(Ssym(Nsym).ne.Ssym1(j)) Cycle
        k1=k1+1; IPsym1(Nsym)=k1; Isym1(k1)=j; ksym1(j)=0
!        kz1 = kz1 + (j-k1)  ! cd
       End do
       Jdet=Isym1(1:ne);  kz1 = Isort(ne,Jdet)
! ... check for the same orbitals the 2-nd configuration:
       IPsym2(Nsym)=k2
       Do j = 1,ne
        if(ksym2(j).eq.0) Cycle
        if(Lsym(Nsym).ne.Lsym2(j)) Cycle
        if(Msym(Nsym).ne.Msym2(j)) Cycle
        if(Ssym(Nsym).ne.Ssym2(j)) Cycle
        k2=k2+1; IPsym2(Nsym)=k2; Isym2(k2)=j; ksym2(j)=0
!        kz2 = kz2 + (j-k2)  ! cd
       End do
      End do
      if(k1.ne.ne) Stop 'Det_breit: k1 <> ne '
! ... exzaust the 2-st configuration:
      Do i = 1,ne
       if(ksym2(i).eq.0) Cycle
       Nsym = Nsym + 1
       Lsym(Nsym)=Lsym2(i); Msym(Nsym)=Msym2(i); Ssym(Nsym)=Ssym2(i)
       k2=k2+1; IPsym2(Nsym)=k2; Isym2(k2)=i; ksym2(i)=0
       IPsym1(Nsym)=k1
!       kz2 = kz2 + (i-k2)
! ... check for the same orbitals rest of 2-st configuration:
       Do j = i+1,ne
        if(ksym2(j).eq.0) Cycle
        if(Lsym(Nsym).ne.Lsym2(j)) Cycle
        if(Msym(Nsym).ne.Msym2(j)) Cycle
        if(Ssym(Nsym).ne.Ssym2(j)) Cycle
        k2=k2+1; IPsym2(Nsym)=k2; Isym2(k2)=j; ksym2(j)=0
        kz2 = kz2 + (j-k2)
       End do
      End do
      if(k2.ne.ne) Stop 'Det_breit: k2 <> ne '
       Jdet=Isym2(1:ne);  kz2 = Isort(ne,Jdet)
!----------------------------------------------------------------------
!                              define the number of different orbitals:
      Ksym1(1)=ipsym1(1)
      Ksym2(1)=ipsym2(1)
      Do i = 2,NSYM
       Ksym1(i)=ipsym1(i)-ipsym1(i-1)
       Ksym2(i)=ipsym2(i)-ipsym2(i-1)
      End do
! ... how much different symmetries:
      k = 0
      Do i = 1,NSYM
       N1(i) = KSYM1(i)-KSYM2(i)
       N2(i) = KSYM2(i)-KSYM1(i)
       if(N1(i).gt.0) k = k + N1(i)
      End do
      if(k.gt.2) Return
!---------------------------------------------------------------------
!                                                         k = 2  case:
      Select case(k)
      Case(2)
       if(joper(3)+joper(5)+joper(6)+joper(7).eq.0) Return
       Do i=1,NSYM
        if(N1(i).le.0) Cycle; i1=i; N1(i)=N1(i)-1; Exit
       End do
       Do i=i1,NSYM
        if(N1(i).le.0) Cycle; i2=i; Exit
       End do
       Do i=1,NSYM
        if(N2(i).le.0) Cycle; j1=i; N2(i)=N2(i)-1; Exit
       End do
       Do i=j1,NSYM
        if(N2(i).le.0) Cycle; j2=i; Exit
       End do
       Call Zno_2ee(i1,i2,j1,j2)
!---------------------------------------------------------------------
!                                                         k = 1  case:
      Case(1)
       if(joper(3)+joper(5)+joper(6)+joper(7).eq.0) Return
       Do i=1,NSYM
        if(N1(i).le.0) Cycle; i1 = i; Exit
       End do
       Do i=1,NSYM
        if(N2(i).le.0) Cycle; j1 = i; Exit
       End do
       Do i = 1,Nsym
        if(Ksym1(i).eq.0) Cycle
        if(i.eq.i1.and.Ksym1(i).le.1) Cycle
        if(i.eq.j1.and.Ksym2(i).le.1) Cycle
        if(i.le.i1.and.i.le.j1)  then
          Call Zno_2ee(i,i1,i,j1)
        elseif(i.gt.i1.and.i.le.j1) then
          Call Zno_2ee(i1,i,i,j1)
        elseif(i.gt.i1.and.i.gt.j1) then
          Call Zno_2ee(i1,i,j1,i)
        elseif(i.le.i1.and.i.gt.j1) then
          Call Zno_2ee(i,i1,j1,i)
        end if
       End do
!---------------------------------------------------------------------
!                                                         k = 0  case:
      Case(0)
       if(joper(1).gt.0)           Call ZNO_0ee
       if(joper(2)+joper(4).gt.0)  Call ZNO_1ee
       if(joper(3)+joper(5)+joper(6)+joper(7).eq.0) Return
       Do i = 1,Nsym
        Do j = i,Nsym
         if(i.eq.j.and.Ksym1(i).le.1) Cycle
         Call Zno_2ee(i,j,i,j)
        End do
       End do
      End Select
      End Subroutine DET_breit


!======================================================================
      Integer(4) Function Idet_fact (j1,j2,j3,j4)
!======================================================================
!
!     determines the overlap factor and its position in NDEF list
!     for matrix element between two determinant wave functions
!     located in module 'spin_orbitals'
!
!     j1,j2,j3,j4 - interacting electrons
!
!     Calls:  Nadd_det, Nadd_def, ISORT
!
!----------------------------------------------------------------------
      USE param_br, ONLY: ibd,ibf
      USE spin_orbitals
      Implicit none
      Integer(4), Intent(in) :: j1,j2,j3,j4
      Integer(4) :: i,i1,i2, k,k1,k2, is,id,kd
      Integer(4), External :: Nadd_det, Nadd_def, ISORT
      kd = 0
      Do is = 1,NSYM
       i1 = 1; if(is.gt.1) i1 = IPsym1(is-1)+1; i2 = IPsym1(is)
       k1 = 0
       Do i = i1,i2
        if(i.eq.j1.or.i.eq.j2) Cycle
        k1 = k1 + 1;  N1(k1) = nnsym1(Isym1(i))
       End do
       i1 = 1; if(is.gt.1) i1 = IPsym2(is-1)+1; i2 = IPsym2(is)
       k2 = 0
       Do i = i1,i2
        if(i.eq.j3.or.i.eq.j4) Cycle
        k2 = k2 + 1;  N2(k2) = nnsym2(Isym2(i))
       End do
       if(k1.ne.k2) Stop 'Idet_fact: k1.ne.k2'
       if(k1.eq.0.or.k2.eq.0) Cycle
       NP(1:k1) = N1(1:k1)*ibd + N2(1:k1);  id = Nadd_det(k1,NP)
       Do k=1,kd
        if(N3(k).ne.id) Cycle;  N4(k)=N4(k)+1; id=0; Exit
       End do
       if(id.eq.0) Cycle
       kd=kd+1; N3(kd)=id; N4(kd)=1
      End do
      Idet_fact=0; if(kd.eq.0) Return
      NP(1:kd)=N3(1:kd)*ibf + N4(1:kd)
      k=ISORT(kd,NP)
      Idet_fact = Nadd_def(kd,NP)
      End Function Idet_fact


!======================================================================
      Integer(4) Function Incode_INT (met,k,I1,I2,I3,I4)
!======================================================================
!
!     incode integral
!
!----------------------------------------------------------------------
      Use param_br
      Implicit none
      Integer(4), intent(in) :: met,k,I1,I2,I3,I4
      if(max(i1,i2,i3,i4).ge.jb) Stop ' INT_pack: i > ibase '
      if(k.gt.mk) Stop 'INT_pack: k > kmax'
      if(met.gt.21) Stop 'INT_pack: met to large'
      Incode_INT = ((i1*jb+i2)*jb+i3)*jb+i4 + k*jb4 + met*jb8
      End Function Incode_INT
!======================================================================
      Subroutine Decode_INT (met,k,I1,I2,I3,I4,int)
!======================================================================
!
!     decode the integral
!
!----------------------------------------------------------------------
      Use param_br
      Implicit none
      Integer(4), Intent(in) :: int
      Integer(4), Intent(out) :: met,k,I1,I2,I3,I4
      K  = int;   met = k/jb8;  k = mod(k,jb8)
      I4 = mod(K,jb);  K  =  K/jb
      I3 = mod(K,jb);  K  =  K/jb
      I2 = mod(K,jb);  K  =  K/jb
      I1 = mod(K,jb);  K  =  K/jb
      End Subroutine Decode_INT


!=====================================================================
!     PROGRAM   B S R _ B R E I T                     main routine
!---------------------------------------------------------------------
      USE param_br; USE inout_br; USE configs; USE inter
      USE det_list; USE def_list; USE coef_list
      Implicit none
      Integer(4) :: klsp
      Integer(4) :: i, ii, nc
      Real(8) :: time, t1,t2,tt, adet,adef
      Real(8), External :: RRTC
      Character AS*80
!----------------------------------------------------------------------
! ... output HEADER:
      Call open_br(pri,0)
      write(pri,'(/20x,a/20x,a/20x,a/)') &
             '=======================',     &
             ' B R E I T - P A U L I ',     &
             '======================='
! ... read arguments from command line:
      Call Read_arg
!----------------------------------------------------------------------
!                                             cycle over partial waves:
      time = 0.d0
      Do klsp = klsp1,klsp2
       write(pri,'(80(''-''))')
       write(pri,'(/a,i5/)') ' Partial wave: ',klsp
       if(klsp.gt.0) write(*,'(/a,i5/)') ' Partial wave: ',klsp
       t1 = RRTC()
! ... open relevant files:
       Call open_br(nuc,klsp)       ! c-file
       Call open_br(nub,klsp)       ! data bank results, if any
       Call open_br(nur,klsp)       ! new results
       Call open_br(nui,klsp)       ! intermediate results
       if(new) write(pri,'(a/)') ' It is new calculations '
       if(.NOT.new) write(pri,'(a/)') ' It is continued calculations '
! ...  read the configuration list:
       Call R_conf
       if(.not.icalc) then; Close(nur,STATUS='DELETE'); Cycle; end if
! ...  extract old results:
       if(new) then
        ndet=0; Call Alloc_det(idet)
        ndef=0; Call Alloc_def(idef)
       else
        read(nub) ndet,ii; jdet = ii/ndet + 1
        Call Alloc_det(ndet+idet)
        Call R_i4(nub,mrecl,ndet,KPD)  ! read(nub) KPD(1:ndet)
        Call R_i4(nub,mrecl,ndet,IPD)  ! read(nub) IPD(1:ndet)
        Call R_i4(nub,mrecl,ii,  NPD)  ! read(nub) NPD(1:ii)
        read(nub) ndef,ii; jdef = ii/ndef + 1
        Call Alloc_def(ndef+idef)
        Call R_i4(nub,mrecl,ndef,KPF)  ! read(nub) KPF(1:ndef)
        Call R_i4(nub,mrecl,ndef,IPF)  ! read(nub) IPF(1:ndef)
        Call R_i4(nub,mrecl,ii,  NPF)  ! read(nub) NPF(1:ii)
        Call RW(nub,nui,ntotc)
        write(pri,'(/a/)') &
          ' Results for the old symmetry calculations:'
        write(pri,'(/3(a,i8))') &
          ' ndet =',ndet,'   ndef  =',ndef,'  ncoef =',ntotc
       end if
! ... prepare det. expantions:
      Call open_br(nua,0); Call open_br(nud,0)
      Call Pre_detexp
! ... calculations for new angular symmetries:
       Call Conf_loop
! ...  record results:
       ii = nsymt*(nsymt+1)/2
       write(nur) ii
       Call W_i1(nur,mrecl,noper,ii,IT_oper) ! write(nur) (IT_oper(:,i),i=1,ii)
       ii=IPD(ndet)+KPD(ndet); adet=ii; adet=adet/ndet
       write(nur) ndet,ii
       Call W_i4(nur,mrecl,ndet,KPD)  ! write(nur) KPD(1:ndet)
       Call W_i4(nur,mrecl,ndet,IPD)  ! write(nur) IPD(1:ndet)
       Call W_i4(nur,mrecl,ii  ,NPD)  ! write(nur) NPD(1:ii)
       ii=IPF(ndef)+KPF(ndef); adef=ii; adef=adef/ndef
       write(nur) ndef,ii
       Call W_i4(nur,mrecl,ndef,KPF)  ! write(nur) KPF(1:ndef)
       Call W_i4(nur,mrecl,ndef,IPF)  ! write(nur) IPF(1:ndef)
       Call W_i4(nur,mrecl,ii  ,NPF)  ! write(nur) NPF(1:ii)
       rewind(nui);  Call RW(nui,nur,nc)
! ...  print the main dimensions:
       write(pri,'(/a/)') &
          ' Results for new angular symmetry calculations:'
       write(pri,'(a,i10,f10.1))') &
          ' number of overlap determinants =', ndet,adet
       write(pri,'(a,i10,f10.1))') &
          ' number of overlap factors      =', ndef,adef
       write(pri,'(a,i10,f10.1))') &
          ' total number of coeff.s        =', ntotc
! ...  rename new results as new data bank (int_res -> int_bnk):
       close(nui); close(nur); close(nub)
       Do i = 1,80; AS(i:i) = ' '; End do
!       AS = 'move '; i = 5               !  Windows
        AS = 'mv ';   i = 3               !  UNIX
       if(klsp.eq.0) then
        ii = LEN_TRIM(AF_r); AS(i+1:i+ii)=AF_r; i=i+ii+1
        ii = LEN_TRIM(AF_b); AS(i+1:i+ii)=AF_b; i=i+ii
       else
        ii = LEN_TRIM(BF_r); AS(i+1:i+ii)=BF_r; i=i+ii+1
        ii = LEN_TRIM(BF_b); AS(i+1:i+ii)=BF_b; i=i+ii
       end if
       Call System(AS(1:i))
! ... time for one partial wave:
       t2=RRTC(); tt=(t2-t1)/60
       write(pri,'(/a,F12.2,a)') ' Partial wave:',tt,' min'
       write(*,     '( a,F12.2,a)') ' Partial wave:',tt,' min'
       time = time + tt
      End do  ! over klsp
!----------------------------------------------------------------------
! ... total time:
      write(pri,'(a,F12.2,a)') ' Total time: ',time,' min'
      write(*,     '(a,F12.2,a)') ' Total time: ',time,' min'
      END ! Program Breit_bsr
!======================================================================
      Subroutine Read_arg
!======================================================================
!
!     read arguments from command line and check default settings
!
!======================================================================
      Use param_br;  Use inter; Use inout_br
      Implicit none
      Character(7) :: oper='1110000'	
! ... read arguments in command line:
      Call Read_iarg('klsp1' ,klsp1 )
      Call Read_iarg('klsp2' ,klsp2 )
      Call Read_iarg('nzero' ,nzero )
      Call Read_iarg('mk'    ,mk    )
      Call Read_iarg('is_soo',is_soo)
      Call Read_aarg('oper'  ,oper  )
      if(klsp2.lt.klsp1) klsp2=klsp1
! ... define the operators under consideration:
      read(oper,'(7i1)') ioper
      write(pri,'(/a/)') ' Operators included: '
      if(ioper(1).gt.0) write(pri,'(a)') ' OVERLAPS'
      if(ioper(2).gt.0) write(pri,'(a)') ' KINATIC ENERGY'
      if(ioper(3).gt.0) write(pri,'(a)') ' TWO-ELECTRON ELECTROSTATIC'
      if(ioper(4).gt.0) write(pri,'(a)') ' SPIN ORBIT'
      if(ioper(5).gt.0) write(pri,'(a)') ' SPIN-OTHER-ORBIT'
      if(ioper(6).gt.0) write(pri,'(a)') ' SPIN-SPIN'
      if(ioper(7).gt.0) write(pri,'(a)') ' ORBIT-ORBIT'
      if(nzero.gt.0) write(pri,'(/a,i8/)') ' Zero order set =',nzero
      write(pri,'(/a,i3/)') ' Max.multipole index =',mk
      if(is_soo.ne.0) &
      write(pri,'(/a,i1/)') ' is_soo = ',is_soo, &
                            ' ->    Vk => V''k '
      End Subroutine Read_arg
!======================================================================
      Subroutine RW(nu1,nu2,nc)
!======================================================================
!
!     re-write bnk-data from file 'nu1' to 'nu2' by blocks
!
!----------------------------------------------------------------------
      Implicit none
      Integer(4), Intent(in) :: nu1,nu2
      Integer(4), Intent(out) :: nc
      Integer(4) :: i,j
      Integer(4),Parameter :: mc = 100000
      Integer(4),Allocatable,Dimension(:) :: K1,K2,K3
      Real(8),Allocatable,Dimension(:) :: C
      Allocate(C(mc),K1(mc),K2(mc),K3(mc))
      nc = 0
      i = 1
    1 read(nu1,end=2) c(i),k1(i),k2(i),k3(i)
      i = i + 1; if(i.le.mc) go to 1
    2 j = i - 1
      nc = nc + j
      Do i = 1,j
       write(nu2) c(i),k1(i),k2(i),k3(i)
      End do
      i = 1;  if(j.eq.mc) go to 1
      Deallocate(C,K1,K2,K3)
	  End Subroutine RW


!======================================================================
      Subroutine Pre_detexp
!======================================================================
!
!     define the det. expansions and write the information
!     in scratch files 'nud' and 'nua'
!
!-----------------------------------------------------------------------
      USE configs;  USE inter;  USE term_exp; Use spin_orbitals
      USE inout_br
      Implicit none
      Integer(4) :: i,j, ij, k,m,kt,kdt,kti,it,it1,it2, jt
      Integer(4) :: IL_dif,IS_dif, mso,msoo,mss
      Integer(4), Allocatable, Dimension(:) :: IPT_jc, IP_kt
      Real(8), Allocatable :: C_det(:)
      Integer(4), Allocatable, Dimension(:,:) ::IP_det
      Real(8), Allocatable :: CC_det(:,:)
      Integer(4), External :: Iglq
!----------------------------------------------------------------------
! ... IPT_jc - pointer on unconsidered configurations:
      if(Allocated(IPT_jc)) Deallocate(IPT_jc); Allocate(IPT_jc(nsymc))
! ... allocations:
      if(.not.allocated(Idet)) Allocate(Idet(ne),Jdet(ne))
!----------------------------------------------------------------------
! ... loop over conf. symmeteries:
      ic_case = 0;  rewind(nud); rewind(nua)
      Do ic=1,nsymc;  if(IC_need(ic).eq.0) Cycle
!----------------------------------------------------------------------
! ... define configuration ic:
       k=IC_term(ic); it1=mod(k,ibc); it2=k/ibc; kti=it2-it1+1
       it = IP_term(it1); no1=noccsh(it); k = 1
       Do i=1,no1
        ln1(i)=nocorb(i,it); iq1(i)=nelcsh(i,it)
        in(i)=k; k=k+iq1(i)
        md(i)=Iglq(ln1(i),iq1(i))
       End do
!----------------------------------------------------------------------
! ... define max. values for shell and intermidiate terms (LS1)
! ... and the number of different angular symmetries (kt):
       LS = 0; kt = 0
       if(Allocated(IP_kt)) Deallocate(IP_kt);  Allocate(IP_kt(kti))
       Do k =it1,it2
        it=IP_term(k); if(IT_stat(it).eq.0) Cycle
        kt = kt + 1; IP_kt(kt) = it
        Do i=1,no1
         if(LSL(i,it).gt.LS(i,2)) LS(i,2)=LSL(i,it)
         if(LSS(i,it).gt.LS(i,3)) LS(i,3)=LSS(i,it)
         if(LPL(i,it).gt.LS(i,4)) LS(i,4)=LPL(i,it)
         if(LPS(i,it).gt.LS(i,5)) LS(i,5)=LPS(i,it)
        End do
       End do
      if(kt.eq.0) then; IC_need(ic)=0; Cycle; end if
      ILT1 = ILT_ic(ic); IST1 = IST_ic(ic)
      if(Allocated(C_det)) Deallocate(C_det);  Allocate(C_det(kt))
!----------------------------------------------------------------------
! ... cycle over all config. symmetries:
      IPT_jc = 1
      Do jc = 1,nsymc
      i=max(ic,jc); j=min(ic,jc); ij=i*(i-1)/2+j
      if(JC_need(ij).eq.0) Cycle
!----------------------------------------------------------------------
! ... define configuration jc (to define orthogonality):
      i=IC_term(jc); m=mod(i,ibc); jt=IP_term(m)
      no2=noccsh(jt)
      Do i=1,no2
       ln2(i)=nocorb(i,jt); iq2(i)=nelcsh(i,jt)
      End do
      ILT2 = ILT_ic(jc); IST2 = IST_ic(jc)
!----------------------------------------------------------------------
! ... orthogonality on l:
      if(ic.ne.jc) then
       nn1=iq1; nn2=iq2
       Do i=1,no1; Do j=1,no2
         if(nn2(j).eq.0) Cycle
         if(ln1(i).eq.ln2(j)) then
          k=min(nn1(i),nn2(j)); nn1(i)=nn1(i)-k; nn2(j)=nn2(j)-k
          if(nn1(i).eq.0) Exit
         end if
       End do; End do
       k = SUM(nn2(1:no2))
       if(k.gt.2) then
        Call DEF_IC(ic,jc); JC_need(ij)=0; IPT_jc(jc)=0
        Cycle  ! over jc
       end if
      end if
!----------------------------------------------------------------------
! ... angular orthogonality:
       IL_dif = iabs(ILT1-ILT2); IS_dif = iabs(IST1-IST2)
       mso = ioper(4); msoo = ioper(5); mss = ioper(6)
       m = 1
       if(ic.ne.jc) then
        if(IL_dif.gt.4.or.IS_dif.gt.4) m = 0
        if(mss.eq.0.and.(IL_dif.gt.2.or.IS_dif.gt.2)) m = 0
        if(mss+mso+msoo.eq.0.and.(IL_dif.gt.0.or.IS_dif.gt.0)) m = 0
       end if
       if(m.eq.0) then
        Call DEF_IC(ic,jc); JC_need(ij)=0; IPT_jc(jc)=0
        Cycle  ! over jc
       end if
!----------------------------------------------------------------------
      if(IPT_jc(jc).eq.0) Cycle    ! here because we should check
                                   ! the above othogonalities
!----------------------------------------------------------------------
! ... define the det. expansion:
       MLT = min(ILT1,ILT2); MST = min(IST1,IST2)
       rewind(nua);  Call DET_EXPN (nua,kti,kt,kdt,IP_kt,C_det)
       if(kdt.eq.0) Stop 'Pre_detexp: kdt = 0'
!----------------------------------------------------------------------
! ... record results:
       ic_case=ic_case+1
       write(nud) ic,kt,kdt,ILT1,IST1,MLT,MST
       write(nud) IP_kt(1:kt)
       rewind(nua)
       Allocate(CC_det(kt,kdt),IP_det(ne,kdt))
       Do i = 1,kdt;  read(nua) IP_det(:,i),CC_det(:,i); End do
       write(nud) IP_det
       write(nud) CC_det
       Deallocate(CC_det,IP_det)
! ... mark the configurations with the same term:
       Do i = jc,nsymc
        if(MLT.eq.min(ILT1,ILT_ic(i)).and. &
           MST.eq.min(IST1,IST_ic(i))) IPT_jc(i)=0
       End do
      End do    ! over jc
      End do    ! over ic
      if(Allocated(IP_kt)) Deallocate(IP_kt)
      if(Allocated(IPT_jc)) Deallocate(IPT_jc)
      if(Allocated(C_det)) Deallocate(C_det)
      End Subroutine Pre_detexp
!======================================================================
      Subroutine Det_expn (nua,kti,kt,kdt,IP_kt,Cdet)
!======================================================================
!
!     procedure of exaustion of all possible determinants
!
!----------------------------------------------------------------------
      USE configs;  USE inter; USE term_exp; Use spin_orbitals
      Implicit none
      Integer(4) :: nua,kt,kti,kd,kdt, i,j,k,m, it, ii
      Integer(4), Dimension(kti) :: IP_kt
      Real(8), Dimension(kt) :: Cdet
      Real(8) :: C
      Real(8), External :: Clebsh,DETC_sh
      kd=0; kdt=0; i=1; nd(i)=1
    1 kd = kd + 1
      ii = in(i)
      Call DET_sh(ln1(i),iq1(i),nd(i),ML(i),MS(i),Idet(ii))
      m = iabs(ML(i)); if(ML(i).lt.0) m = m + 2
      if(m.gt.LS(i,2)) go to 2
      m = iabs(MS(i)); if(MS(i).lt.0) m = m + 2
      if(m.gt.LS(i,3)) go to 2
      if(i.eq.1) then
       MLp(1)=ML(1); MSp(1)=MS(1)
      else
       MLp(i) = MLp(i-1)+ML(i)-1
       MSp(i) = MSp(i-1)+MS(i)-1
       m = iabs(MLp(i)); if(MLp(i).lt.0) m = m + 2
       if(m.gt.LS(i,4)) go to 2
       m = iabs(MSp(i)); if(MSp(i).lt.0) m = m + 2
       if(m.gt.LS(i,5)) go to 2
      end if
      if(i.lt.no1) then; i = i + 1; nd(i) = 1;  go to 1; end if
      if(MLp(no1).ne.MLt) go to 2
      if(MSp(no1).ne.MSt) go to 2
!--------------------------------------------------------------------
!                                            coefficient calculation:
      Cdet = 0.d0
      Do k=1,kt; it = IP_kt(k); C=1.d0
       Do j=1,no1
        ii = LSA(j,it); C=C*DETC_sh(ln1(j),iq1(j),ii,nd(j))
        if(C.eq.0.d0) Exit
       End do
       if(C.eq.0.d0) Cycle
       Do j = 2,no1
        C = C *  Clebsh(LPL(j-1,it),MLp(j-1), &
                          LSL(j,it),ML(j),LPL(j,it),MLp(j))
        if(C.eq.0.d0) Exit
        C = C *  Clebsh(LPS(j-1,it),MSp(j-1), &
                          LSS(j,it),MS(j),LPS(j,it),MSp(j))
        if(C.eq.0.d0) Exit
       End do
       Cdet(k) = C
      End do
      kdt=kdt+1; write(nua) Idet,Cdet
!--------------------------------------------------------------------
    2 nd(i)=nd(i)+1                ! selecting the next case
      if(nd(i).gt.md(i)) then
       if(i.eq.1) go to 3          ! to end
       i=i-1; go to 2
      end if
      go to 1
    3 Continue
      End Subroutine Det_expn


!======================================================================
      Subroutine R_conf
!======================================================================
!
!     Read the configuration list from c-file (unit 'nuc'),
!     define there angular symmetries and compare with existing ones.
!     Prepare the angular arrays.
!
!     nub, nui - file units for old and new results, respectively
!
!----------------------------------------------------------------------
      USE inout_br;  USE configs; USE inter; USE term_exp
      Implicit none
      Character(26) :: AI  ! config. symmetry
      Character(40) :: BI  ! angular symmetry
      Character(26), Allocatable, Dimension(:) :: ASYM
      Character(40), Allocatable, Dimension(:) :: BSYM
! ... IT_conf(it) gives the configuration for given term 'it'
      Integer(4), Allocatable, Dimension(:) :: IT_conf
      Integer(4), External :: Iterm, Idef_ncfg, IC_calc
      Integer(4) :: i,j, ii,it, msymc,msymt,iconf,jterm,ndim1,ndim2
! ... define ncfg:
      ncfg=Idef_ncfg(nuc)
      if(ncfg.eq.0) Stop ' ncfg = 0, nothing to do '
! ... read old information, if any:
      if(new) then
       nsymt=0; nsymc=0; msymt = ncfg; msymc = ncfg
       if(Allocated(IT_conf)) Deallocate (IT_conf,ASYM,BSYM,IP_stat)
       Allocate(IT_conf(msymt),ASYM(msymc),BSYM(msymt),IP_stat(msymt))
       IT_conf = 0
      else
       read(nub) nsymt, nsymc
       write(pri,'(a/)')    ' int_bnk contains: '
       write(pri,'(a,i5))') ' number of configurations  = ',NSYMC
       write(pri,'(a,i5))') ' number of ang. symmetries = ',NSYMT
       msymt = nsymt + ncfg
       msymc = nsymc + ncfg
       if(Allocated(IT_conf)) Deallocate (IT_conf,ASYM,BSYM,IP_stat)
       Allocate(IT_conf(msymt),ASYM(msymc),BSYM(msymt),IP_stat(msymt))
       Call R_a (nub,mrecl,nsymc,ASYM)    ! read(nub) ASYM(1:nsymc)
       Call R_a (nub,mrecl,nsymt,BSYM)    ! read(nub) BSYM(1:nsymt)
       Call R_i4(nub,mrecl,nsymt,IT_conf) ! read(nub) IT_conf(1:nsymt)
      end if
      IP_stat = 0
!---------------------------------------------------------------------
! ... define new symmetries from c-file:
      rewind(nuc); parity=0
      Do
       read(nuc,'(a)') CONFIG
       if(CONFIG(1:1).eq.'*') Exit
       if(CONFIG(5:5).ne.'(') Cycle
       read(nuc,'(a)') COUPLE
       Call Decode_c;  Call TEST_C
! ... check angular symmetry:
       Call Incode_conf(AI,BI)
       iconf=0
       Do i=1,nsymc
        if(AI.ne.ASYM(i)) Cycle; iconf=i; Exit
       End do
       if(iconf.eq.0) then
        nsymc=nsymc+1; iconf=nsymc; ASYM(nsymc)=AI
       end if
       jterm = 0
       Do i=1,nsymt
        if(BI.ne.BSYM(i) .or. IT_conf(i).ne.iconf) Cycle
        jterm=i; Exit
       End do
       if(jterm.eq.0) then
        nsymt=nsymt+1; BSYM(nsymt)=BI; IT_conf(nsymt)=iconf
        jterm = nsymt
       end if
       IP_stat(jterm) = 1       ! simply indicates existence
      End do  ! on ic
      write(pri,'(/a/)')   ' c-fail (cfg.inp) contains: '
      write(pri,'(a,i5))') ' number of atomic states   = ',NCFG
      write(pri,'(a,i5))') ' number of configurations  = ',NSYMC
      write(pri,'(a,i5))') ' number of ang. symmetries = ',NSYMT
      write(*,'(/a/)')   ' c-fail (cfg.inp) contains: '
      write(*,'(a,i5))') ' number of atomic states   = ',NCFG
      write(*,'(a,i5))') ' number of configurations  = ',NSYMC
      write(*,'(a,i5))') ' number of ang. symmetries = ',NSYMT
      if(nsymt.ge.ibc) Stop ' R_conf: nsymt > ibc '
!----------------------------------------------------------------------
! ... define IP_term and IC_term pointers:
      if(Allocated(IP_term)) Deallocate(IP_term,IC_term)
      Allocate(IP_term(nsymt),IC_term(nsymc))
      Call Isort1(nsymt,IT_conf,IP_term)
      IC_term=0
      Do i=1,nsymt
       it=IP_term(i); ic=IT_conf(it)
       if(IC_term(ic).eq.0) then
        IC_term(ic) = i + ibc*i
       else
        j=mod(IC_term(ic),ibc); IC_term(ic) = j + ibc*i
       end if
      End do
      if(Allocated(IT_stat)) Deallocate(IT_stat)
      Allocate(IT_stat(nsymt)); IT_stat = IP_stat(1:nsymt)
!----------------------------------------------------------------------
!     define if we need additional calculations
      if(allocated(IT_oper)) Deallocate(IT_oper, IC_need, JC_need)
      Allocate(IT_oper(1:noper,nsymt*(nsymt+1)/2),IC_need(nsymc),  &
               JC_need(nsymc*(nsymc+1)/2))
      IT_oper = 0
      if(new) then
       icalc=.TRUE.; IC_need = 1; JC_need = 1
      else
       read(nub) ii; ndim1=noper; ndim2=nsymt*(nsymt+1)/2
       Call R_i1(nub,mrecl,ndim1,ndim2,ii,IT_oper) ! read(nub) (IT_oper(:,i),i=1,ii)
       IC_need=0; icalc=.FALSE.
       Do ic=1,nsymc
        Do jc=1,ic
         i = IC_calc(ic,jc); JC_need(ic*(ic-1)/2+jc) = i
         if(i.gt.0) then
		  IC_need(ic) = 1; IC_need(jc) = 1; icalc=.TRUE.
		 end if
        End do
       End do
      end if
      if(icalc) then
       write(pri,'(/a,a4/)') ' Need of additional calculations --> yes '
       write(*,'(/a,a4/)')   ' Need of additional calculations --> yes '
      else
       write(pri,'(/a,a4/)') ' Need of additional calculations --> no '
       write(*,'(/a,a4/)')   ' Need of additional calculations --> no '
      end if
      if(.NOT.icalc) then
       Deallocate(IT_conf, IP_stat, ASYM, BSYM)
       Return
      end if
!----------------------------------------------------------------------
! ... record new information:
      write(nur) nsymt, nsymc
      Call W_a (nur,mrecl,nsymc,ASYM)    ! write(nur) ASYM(1:nsymc)
      Call W_a (nur,mrecl,nsymt,BSYM)    ! write(nur) BSYM(1:nsymt)
      Call W_i4(nur,mrecl,nsymt,IT_conf) ! write(nur) IT_conf(1:nsymt)
!----------------------------------------------------------------------
! ... define angular arrays:
      if(Allocated(NOCCSH)) Deallocate(NOCCSH, NELCSH, NOCORB, &
               LSA, LSL, LSS, LPL, LPS, ILT_ic,IST_ic)
      Allocate(NOCCSH(nsymt), NELCSH(nsh,nsymt), NOCORB(nsh,nsymt), &
               LSA(nsh,nsymt), LSL(nsh,nsymt), LSS(nsh,nsymt),      &
               LPL(nsh,nsymt), LPS(nsh,nsymt),                      &
               ILT_ic(nsymc),IST_ic(nsymc)  )
      Do it = 1,nsymt
       ic = IT_conf(it)
       Call Decode_conf(ASYM(ic),BSYM(it))
       noccsh(it)=no
       Do i=1,no
        nelcsh(i,it)= iq(i)
        nocorb(i,it)= ln(i)
        LSA(i,it) = Iterm (ln(i),iq(i),0,LS(i,1),LS(i,2),LS(i,3))
        LSL(i,it) = LS(i,2)
        LSS(i,it) = LS(i,3)
        LPL(i,it) = LS(i,4)
        LPS(i,it) = LS(i,5)
       End do
       ILT_ic(ic) = LS(no,4)
       IST_ic(ic) = LS(no,5)
      End do
      Deallocate(IT_conf, IP_stat, ASYM, BSYM)
      End Subroutine R_conf


!======================================================================
      Subroutine TERM_loop
!======================================================================
!
!     Add to the common list (coef_list) the coeff.s between two
!     determinants (zoef_list) weighted with term-dependent factors.
!     Check also if the specific coefficient is needed to be added
!     to the bank.
!
!----------------------------------------------------------------------
      USE param_br; USE inter; USE term_exp
      USE zoef_list; USE coef_list
      Implicit none
      Integer(4) :: i,k,m, it,jt, k1,k2
      Real(8) :: C
!----------------------------------------------------------------------
! ... find term-dependent coefficients between two determinants:
      k = 0
      Do k1=1,kt1; it=IP_kt1(k1)
      Do k2=1,kt2; jt=IP_kt2(k2)
       if(ic.eq.jc.and.it.gt.jt) Cycle
       k = k + 1;  Ctrm(k) = C_det1(k1,kd1)*C_det2(k2,kd2)
      End do; End do
!----------------------------------------------------------------------
! ... define term- and operator-dependent coefficients:
      Do i = 1,noper
       if(joper(i).eq.0) Cycle
       CT_oper(:,i) = Coper(i)*JT_oper(1:ntrm,i)*Ctrm(1:ntrm)
      End do
!----------------------------------------------------------------------
! ... add final coefficients:
      Do i=1,nzoef
       C = Zoef(i); if(abs(C).lt.EPS_c) Cycle
       int = IZ_int(i); idf = IZ_df(i);  m = int/jb8; jcase=m
       Select case (m)
        Case(3,4); if(joper(7).eq.0) Cycle; Ctrm(1:ntrm)=C*CT_oper(:,7)
        Case(5);   if(joper(3).eq.0) Cycle; Ctrm(1:ntrm)=C*CT_oper(:,3)
        Case(6);   if(joper(2).eq.0) Cycle; Ctrm(1:ntrm)=C*CT_oper(:,2)
        Case(7);   if(joper(4).eq.0) Cycle; Ctrm(1:ntrm)=C*CT_oper(:,4)
        Case(8,9); if(joper(5).eq.0) Cycle; Ctrm(1:ntrm)=C*CT_oper(:,5)
        Case(10);  if(joper(6).eq.0) Cycle; Ctrm(1:ntrm)=C*CT_oper(:,6)
        Case(11);  if(joper(1).eq.0) Cycle; Ctrm(1:ntrm)=C*CT_oper(:,1)
        Case Default;  Stop ' Term_loop: unknown integral '
       End select
       Call Add_coef
      End do
      nzoef = 0
      End  Subroutine TERM_loop


!====================================================================
      Subroutine ZNO_0ee
!====================================================================
!
!     computes overlap integral between two determinants
!
!     Calls: Idet_fact, Incode_int, Iadd_zoef
!
!--------------------------------------------------------------------
      USE spin_orbitals
      Implicit none
      Integer(4) :: idf,int
      Real(8) :: C
      Integer(4), External :: Idet_fact, Incode_int
      C = (-1)**(kz1+kz2)
      idf = Idet_fact (0,0,0,0)
      int = Incode_int (11,0,1,1,1,1)
      Call Iadd_zoef (C,int,idf)
      End Subroutine ZNO_0ee


!====================================================================
      Subroutine ZNO_1ee
!====================================================================
!
!    angular part of one-electron operator between two det.w.f
!
!    Calls: Idet_fact, Incode_int, Iadd_zoef.
!
!--------------------------------------------------------------------
      Use inter;  Use spin_orbitals
      Implicit none
      Integer(4) :: i,j,i1,i2,k,k1,k2,is,idf,int
      Real(8) :: C,CFF
      Integer(4), External :: Idet_fact, Incode_int
      Do is = 1,NSYM
       i1 = 1; if(is.gt.1) i1=IPsym1(is-1)+1; i2=IPsym1(is)
       Do i=i1,i2; k=Isym1(i); k1=nnsym1(k)
       Do j=i1,i2; k=Isym2(j); k2=nnsym2(k)
       idf = Idet_fact(i,0,j,0)
       C=(-1)**(kz1+kz2+i+j)
       if(joper(2).gt.0) then                          ! L-integrals
        int = Incode_int (6,0,k1,k1,k2,k2)
        CFF=-0.5;  Call Iadd_zoef(C*CFF,int,idf)
       end if
       if(joper(4).gt.0.and.Msym(is).ne.0) then        ! Z-integrals
        C = C * Msym(is) * (Ssym(is)-1)
        int = Incode_int (7,0,k1,k1,k2,k2)
        Call Iadd_zoef(C,int,idf)
       end if
       End do
       End do
      End do
      END Subroutine ZNO_1ee


!======================================================================
      SUBROUTINE ZNO_2ee (i1,i2,j1,j2)
!======================================================================
!
!     angular part of matrix elements between two det.w.f.
!     for two-electron operator
!
!     Calls: Check_boef, Idet_fact, Iadd_zoef.
!
!----------------------------------------------------------------------
      USE spin_orbitals;  USE BOEF_list
      Implicit none
      Integer(4), Intent(in) :: i1,i2,j1,j2
      Integer(4) :: i11,i12,i21,i22,j11,j12,j21,j22
      Integer(4) :: io1,io2,io3,io4, ib1,ib2,ib3,ib4
      Integer(4) :: i,j,k, k1,k2,k3,k4, met,int,idf,kz,ii1,ii2
      Integer(4) :: ibint(4)
      Integer(4), External :: Idet_fact, Incode_int
!----------------------------------------------------------------------
      if(mod(Lsym(i1)+Lsym(i2)+Lsym(j1)+Lsym(j2),2).ne.0) Return
      if(Msym(i1)+Msym(i2).ne.Msym(j1)+Msym(j2)) Return
      if(Ssym(i1)+Ssym(i2).ne.Ssym(j1)+Ssym(j2)) Return
!----------------------------------------------------------------------
      Call Check_boef(Lsym(i1),Msym(i1),Ssym(i1), &
                      Lsym(i2),Msym(i2),Ssym(i2), &
                      Lsym(j1),Msym(j1),Ssym(j1), &
                      Lsym(j2),Msym(j2),Ssym(j2))
!----------------------------------------------------------------------
!
      i11 = 1;  if(i1.gt.1) i11 = IPsym1(i1-1)+1;  i12 = IPsym1(i1)
      i21 = 1;  if(i2.gt.1) i21 = IPsym1(i2-1)+1;  i22 = IPsym1(i2)
      j11 = 1;  if(j1.gt.1) j11 = IPsym2(j1-1)+1;  j12 = IPsym2(j1)
      j21 = 1;  if(j2.gt.1) j21 = IPsym2(j2-1)+1;  j22 = IPsym2(j2)
      Do k1 = i11,i12;  i=Isym1(k1); ibint(1)=nnsym1(i)
      Do k2 = i21,i22;  j=Isym1(k2); ibint(2)=nnsym1(j)
                         if(k2.le.k1) Cycle
                        ! if(i.ge.j) Cycle
      Do k3 = j11,j12;  i=Isym2(k3);  ibint(3)=nnsym2(i)
      Do k4 = j21,j22;  j=Isym2(k4);  ibint(4)=nnsym2(j)
                         if(k4.le.k3) Cycle
                        ! if(i.ge.j) Cycle
       idf = Idet_fact(k1,k2,k3,k4)
       kz = (-1)**(kz1+kz2+k1+k2+k3+k4)
       ii1 = 1; if(kblk.gt.1) ii1=ncblk(kblk-1)+1; ii2=ncblk(kblk)
       Do i = ii1,ii2
        Call Decode_int (met,k,ib1,ib2,ib3,ib4,IB_int(i))
        io1 = ibint(ib1); io2 = ibint(ib2)
        io3 = ibint(ib3); io4 = ibint(ib4)
        Call Jsym_int(met,io1,io2,io3,io4)
        int = Incode_Int (met,k,io1,io2,io3,io4)
        Call Iadd_zoef(Boef(i)*kz,int,idf)
       End do
      End do;  End do;  End do;  End do
      END SUBROUTINE ZNO_2ee
!======================================================================
      Subroutine Jsym_int(icase,j1,j2,j3,j4)
!======================================================================
      Implicit none
      Integer(4) :: icase,j,j1,j2,j3,j4
      if(icase.eq.3.or.icase.eq.4.or.icase.eq.5) then
       if(j1.gt.j2) then
        j=j1;j1=j2;j2=j; j=j3;j3=j4;j4=j
       elseif(j1.eq.j2.and.j3.gt.j4) then
        j=j3;j3=j4;j4=j
       end if
      end if
      End Subroutine Jsym_int


!======================================================================
      Subroutine ZNO_breit( no1,l1,m1,ms1,no2,l2,m2,ms2,  &
                            no3,l3,m3,ms3,no4,l4,m4,ms4,  ide)
!======================================================================
!
!     computes angular coefficients for the two-electron Breit-Pauli
!     operators in uncouple nlms-representation.
!
!     ide = +1  ->  direct interaction
!     ide = -1  ->  exchange interaction
!
!----------------------------------------------------------------------
      USE inter, ONLY: joper
      Use param_br, ONLY: mk, is_soo
      Implicit none
      Integer(4), Intent(in) :: no1,l1,m1,ms1,no2,l2,m2,ms2,  &
                                no3,l3,m3,ms3,no4,l4,m4,ms4,  ide
      Integer(4) :: q,qq, k,kk, k1,k2, kq,kz
      Integer(4) :: KL,KM, KL1,KL2, KM1,KM2, met
      Integer(4) :: mkk=0
      Real(8),Allocatable,Dimension(:) :: A1,A2,B1,B2
      Real(8) :: C, C1,C2, CQ, S,SS,S1,S2,A,AB, FS1,FS2
      Real(8) :: D0 = 0.d0
      Real(8), External :: Z_3jj
      if(Allocated(A1)) Deallocate(A1,A2,B1,B2)
      mkk = mk + 3
      Allocate(A1(0:mkk),A2(0:mkk),B1(0:mkk),B2(0:mkk))
!---------------------------------------------------------------------
! ... define the range of multipole indeces and common multipliers:
      KL1=IABS(l1-l3);  KL2=IABS(l2-l4);  KL=MAX0(KL1,KL2)
      KM1= l1+l3;       KM2=l2+l4;        KM=MIN0(KM1,KM2)
      if(KM.lt.KL) Return
      S = (l1+l1+1)*(l2+l2+1)*(l3+l3+1)*(l4+l4+1)
      S = sqrt(S) * ide * (-1)**(m3+m4)
      q = m1-m3; kq = (-1)**q
!---------------------------------------------------------------------
! ... define all relevant 3j-symbols:
      DO kk = 0,KM-KL+3
       k = KL + kk - 1; if(k.gt.mk) Cycle
       A1(kk)=D0; B1(kk)=D0
       if(k.ge.KL1.and.k.le.KM1) then
        if(mod(l1+l3+k,2).eq.0) A1(kk) = Z_3jj(l1,0,l3,0,k,0)
        B1(kk) = Z_3jj(l1,-m1,l3,m3,k,m1-m3)
       end if
       A2(kk)=D0; B2(kk)=D0
       if(k.ge.KL2.and.k.le.KM2) then
        if(mod(l2+l4+k,2).eq.0) A2(kk) = Z_3jj(l2,0,l4,0,k,0)
        B2(kk) = Z_3jj(l2,-m2,l4,m4,k,m2-m4)
       end if
      End do
!----------------------------------------------------------------------
! ... cycle on multypoles:
      Do kk = 1,km-kl+1,2
       k = kl + kk - 1; if(k.gt.mk) Cycle
       AB = A1(kk)*B1(kk)*A2(kk)*B2(kk)*S *kq      ! dk * dk * (-1)^q
!----------------------------------------------------------------------
! ... e-e interaction:
      C = AB
      if(joper(3).gt.0.and.ms1.eq.ms3.and.ms2.eq.ms4) then
       met=5; Call Add_ci(C,met,k,no1,no2,no3,no4)  ! R[k](r,s;r',s')
      end if
!---------------------------------------------------------------------
! ... o-o interaction (with Uk --> Tk + Tk'):
      if(joper(7).ne.0.and.ms1.eq.ms3.and.ms2.eq.ms4) then
       C = -AB
       if(k.gt.0.and.C.ne.D0) then
       S1=l1*(l1+1)-l3*(l3+1)-k*(k+1)
       S2=l2*(l2+1)-l4*(l4+1)-k*(k+1)
       SS=S1*S2
       met = 3; A = 2*k*(k+1)*C
       CALL ADD_ci( A,met,k+1,no1,no2,no3,no4)      ! T[k+1](r,s;r',s')
       CALL ADD_ci(-A,met,k-1,no1,no2,no3,no4)      ! T[k-1](r,s;r',s')
!      for Uk-inegrals, we use the replacement:
!      U(1,2;3,4) = T(1,2;3,4) + T(3,2;1;4)
!      [W.Dankwort, J.Phys.B10,L369(1977)]
       A = S1*C
       CALL ADD_ci( A,met,k+1,no1,no2,no3,no4)      ! U[k+1](r,s;r',s')
       CALL ADD_ci( A,met,k+1,no3,no2,no1,no4)
       CALL ADD_ci(-A,met,k-1,no1,no2,no3,no4)      ! U[k-1](r,s;r',s')
       CALL ADD_ci(-A,met,k-1,no3,no2,no1,no4)
       A = S2*C
       CALL ADD_ci( A,met,k+1,no2,no1,no4,no3)      ! U[k+1](s,r;s',r')
       CALL ADD_ci( A,met,k+1,no4,no1,no2,no3)
       CALL ADD_ci(-A,met,k-1,no2,no1,no4,no3)      ! U[k-1](s,r;s',r')
       CALL ADD_ci(-A,met,k-1,no4,no1,no2,no3)
       met = 4;  A = C*SS*(k-2)/k/(k+k-1)   ! /2 ?
       CALL ADD_ci( A,met,k-1,no1,no2,no3,no4)      ! M[k-2](r,s;r',s')
       A = -C*SS*(k+3)/(k+1)/(k+k+3)  ! /2 ?
       CALL ADD_ci( A,met,k+1,no1,no2,no3,no4)      ! M[k](r,s;r',s')
       end if   ! (k>0)
       met=4
       C = -A1(kk)*B1(kk+1)*A2(kk)*B2(kk+1)*S*kq
       if(C.ne.D0) then
        A =(l1+l3+k+2)*(l3-l1+k+1)*(l1-l3+k+1)*(l1+l3-k)*   &
           (l2+l4+k+2)*(l4-l2+k+1)*(l2-l4+k+1)*(l2+l4-k)
        A=C*sqrt(A)/((k+1)*(k+2))*2
        CALL ADD_ci(A,met,k+1,no1,no2,no3,no4)      ! M[k](r,s;r',s')
       end if
      end if
!----------------------------------------------------------------------
! ... s-s interaction:
      if(joper(6).ne.0) then
       met=10
       kz=(ms1+ms2)/2;  kz=kq*(-1)**(kz+1)
       k1=k+1;  k1=k1*k1;  k2=k+2;  k2=k2*k2;  qq=q*q
       A=(k1-qq)*(k2-qq); A=sqrt(A); A=A*S*kz
       C  = A1(kk+2)*B1(kk+2)*A2(kk)*B2(kk)*A       ! N[k](r,s;r',s')
       CALL ADD_ci(C,met,k+1,no1,no2,no3,no4)
       C  = A1(kk)*B1(kk)*A2(kk+2)*B2(kk+2)*A       ! N[k](s,r;s',r')
       CALL ADD_ci(C,met,k+1,no2,no1,no4,no3)
      end if
!----------------------------------------------------------------------
! ... s-o-o interaction :
      if(joper(5).ne.0.and.ms1.eq.ms3.and.ms2.eq.ms4) then
       FS1=(ms1+ms2+ms2-3); FS2=(ms2+ms1+ms1-3)
!----------------------------------------------------------------------
      if(is_soo.eq.0) then   ! without  Vk --> V'k
       met=9                                        ! V[k-1](r,s;r',s')
       CQ = D0;  if(iabs(q).le.k)  CQ = q
       if(k.gt.0) then
        C  = AB*CQ
        C1 = -C*FS1; CALL ADD_ci(C1,met,k,no1,no2,no3,no4)
        C2 =  C*FS2; CALL ADD_ci(C2,met,k,no2,no1,no4,no3)
       end if
       met=8                                        ! N[k](r,s;r',s')
       if(k*l3.gt.0) then
        C = C/(k+1)/2
        C1 = l1*(l1+1)-l3*(l3+1)-k*(k+1)
        C1 = -C1*C*FS1
        CALL ADD_ci(C1,met,k+1,no1,no2,no3,no4)     ! N[k]
        C1 = -C1*(k+1)/k
        CALL ADD_ci(C1,met,k-1,no2,no1,no4,no3)     ! N[k-2]
       end if
       if(k*l4.gt.0) then
        C2 = l2*(l2+1)-l4*(l4+1)-k*(k+1)
        C2 = C2*C*FS2
        CALL ADD_ci(C2,met,k+1,no2,no1,no4,no3)     ! N[k]
        C2= -C2*(k+1)/k
        CALL ADD_ci(C2,met,k-1,no1,no2,no3,no4)     ! N[k-2]
       end if
      else        ! with  Vk --> V'k
       met=9                                        ! V[k-1](r,s;r',s')
       CQ = D0;  if(iabs(q).le.k)  CQ = q
       if(k.gt.0) then
        C  = AB*CQ/2
        C1 = -C*FS1; CALL ADD_ci(C1,met,k,no1,no2,no3,no4)
        C2 =  C*FS2; CALL ADD_ci(C2,met,k,no2,no1,no4,no3)
       end if
       met=8                                        ! N[k](r,s;r',s')
       if(k.gt.0) then
        C = C/(k+1)
        C1 = l1*(l1+1)-l3*(l3+1)
        C1 = -C1*C*FS1
        CALL ADD_ci(C1,met,k+1,no1,no2,no3,no4)     ! N[k]
        C1 = -C1*(k+1)/k
        CALL ADD_ci(C1,met,k-1,no2,no1,no4,no3)     ! N[k-2]
       end if
       if(k.gt.0) then
        C2 = l2*(l2+1)-l4*(l4+1)
        C2 = C2*C*FS2
        CALL ADD_ci(C2,met,k+1,no2,no1,no4,no3)     ! N[k]
        C2= -C2*(k+1)/k
        CALL ADD_ci(C2,met,k-1,no1,no2,no3,no4)     ! N[k-2]
       end if
      end if  ! on is_soo
!----------------------------------------------------------------------
       CQ = D0; if(iabs(q).le.k) CQ = (k+q+1)*(k-q+1)
       CQ = sqrt(CQ)* kq /(2*(k+1))
       C  = A1(kk)*B1(kk+1)*A2(kk)*B2(kk)*S*CQ
       C1 = (l1+l3+k+2)*(l1+l3-k)*(l3-l1+k+1)*(l1-l3+k+1)
       C1 = sqrt(C1)*C*FS1
       if(l3.gt.0) CALL ADD_ci(C1,met,k+1,no1,no2,no3,no4) ! N[k]
       C  = A1(kk)*B1(kk)*A2(kk)*B2(kk+1)*S*CQ
       C2 = (l2+l4+k+2)*(l2+l4-k)*(l4-l2+k+1)*(l2-l4+k+1)
       C2 = sqrt(C2)*C*FS2
       if(l4.gt.0) CALL ADD_ci(C2,met,k+1,no2,no1,no4,no3) ! N[k]
       if(k.gt.0) then
       CQ = D0
       if(iabs(q).le.k) CQ = (k+q)*(k-q); CQ = -sqrt(CQ)*kq /(2*k)
       C  = A1(kk)*B1(kk-1)*A2(kk)*B2(kk)*S*CQ
       C1 = (l1+l3+k+1)*(l1+l3-k+1)*(l3-l1+k)*(l1-l3+k)
       C1 = sqrt(C1)*C*FS1
       CALL ADD_ci(C1,met,k-1,no2,no1,no4,no3)             ! N[k-2]
       C  = A1(kk)*B1(kk)*A2(kk)*B2(kk-1)*S*CQ
       C2 = (l2+l4+k+1)*(l2+l4-k+1)*(l4-l2+k)*(l2-l4+k)
       C2 = sqrt(C2)*C*FS2
       CALL ADD_ci(C2,met,k-1,no1,no2,no3,no4)             ! N[k-2]
       end if   ! on k>0
      end if
!---------------------------------------------------------------------
      End do   ! over k
      if(Allocated(A1)) Deallocate(A1,A2,B1,B2)
      End Subroutine ZNO_breit
!======================================================================
      Subroutine Add_ci(C,met,k,j1,j2,j3,j4)
!======================================================================
!
!     control the recording of one resulting integral
!     with possible replacement by combination of others,
!     more simple, integrals.
!
!     Calls: Incode_int, Iadd_boef
!
!----------------------------------------------------------------------
      Use param_br, ONLY: Eps_c, mk
      Implicit none
      Integer(4), Intent(in) :: met,k,j1,j2,j3,j4
      Real(8), Intent(in) :: C
      Integer(4) :: int
      Integer(4), External :: Incode_int
      if(abs(C).lt.Eps_c) Return;  if(k.gt.mk) Return
      int = Incode_int(met,k,j1,j2,j3,j4); Call Iadd_boef(C,int)
!     the following replacements are not more used:
!----------------------------------------------------------------------
!                                                        T[k] --> N[k]:
!
!     if(met.eq.3.and.j1.eq.j2.and.j2.eq.j3.and.j3.eq.j4) then
!
!      S=-C*(k-1)*(k+2)/(k+k+1)/2
!      int=0
!      Call INT_pack(4,k,j1,j2,j3,j4,int)
!      i=Iadd_boef(S,int)
!
!     Here are used the relations:
!
!     U[k](a,b;c,d) + U[k](c,d;a,b) =    A(a,b;c,d) -
!
!     - (k-1)(k+2)/(2k+1) { N[k-1](a,b;c,d) + N[k-1](b,a;d,c) }
!
!     and   U[k](a,b;c,d) = T[k](a,b;c,d) + T[k](c,b;a,d).
!
!     then a=b=c=d the integrals A(a,a,a,a) disapear so the T and U
!     integrals enter only as I[k+1] - I[k-1].
!
!     In particular:  Uk(a,a,a,a)=2Tk(a,a,a,a)
!                                =-(k-1)(k+2)/(2k+1) (1/2) N'[k-1]
!
!----------------------------------------------------------------------
!                                                        V[k] --> N[k]:
!
!     elseif(met.eq.9.and.j1.eq.j3.and.j2.eq.j4) then
!
!      S=-C*(k+1)/2
!      int=0
!      Call INT_pack(8,k-1,j1,j2,j3,j4,int)
!      i=Iadd_boef(S,int)
!      S= C*(k+0)/2
!      int=0
!      Call INT_pack(8,k+1,j1,j2,j3,j4,int)
!      i=Iadd_boef(S,int)
!
!      here is used the relation:   (R.Glass, Z.Physik,A292,131(1979))
!
!      2*V[k](r,s;r,s) = -(k+2)*N[k-1](s,r;s,r) + (k+1)N[k+1](r,s;r,s)
!
!      that is consequence of more general relation
!
!      V[k](r,s;r's') + V[k](r's';r,s) =
!                 -(k+2)*N[k-1](s,r;s',r') + (k+1)N[k+1](r,s;r',s')
!
!----------------------------------------------------------------------
      End Subroutine Add_ci


